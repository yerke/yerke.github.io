<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Embedonomicon</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="smallest-no-std.html"><strong aria-hidden="true">1.</strong> The smallest #![no_std] program</a></li><li><a href="memory-layout.html"><strong aria-hidden="true">2.</strong> Memory layout</a></li><li><a href="main.html"><strong aria-hidden="true">3.</strong> A main interface</a></li><li><a href="exceptions.html"><strong aria-hidden="true">4.</strong> Exception handling</a></li><li><a href="asm.html"><strong aria-hidden="true">5.</strong> Assembly on stable</a></li><li><a href="logging.html"><strong aria-hidden="true">6.</strong> Logging with symbols</a></li><li><a href="singleton.html"><strong aria-hidden="true">7.</strong> Global singletons</a></li><li><a href="dma.html"><strong aria-hidden="true">8.</strong> DMA</a></li><li class="spacer"></li><li class="affix"><a href="compiler-support.html">A note on compiler support</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Embedonomicon</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-embedonomicon" id="the-embedonomicon"><h1>The embedonomicon</h1></a>
<p>The embedonomicon walks you through the process of creating a <code>#![no_std]</code> application from scratch
and through the iterative process of building architecture-specific functionality for Cortex-M
microcontrollers.</p>
<a class="header" href="#objectives" id="objectives"><h2>Objectives</h2></a>
<p>By reading this book you will learn</p>
<ul>
<li>
<p>How to build a <code>#![no_std]</code> application. This is much more complex than building a <code>#![no_std]</code>
library because the target system may not be running an OS (or you could be aiming to build an
OS!) and the program could be the only process running in the target (or the first one).
In that case, the program may need to be customized for the target system.</p>
</li>
<li>
<p>Tricks to finely control the memory layout of a Rust program. You'll learn about linkers, linker
scripts and about the Rust features that let you control a bit of the ABI of Rust programs.</p>
</li>
<li>
<p>A trick to implement default functionality that can be statically overridden (no runtime cost).</p>
</li>
</ul>
<a class="header" href="#target-audience" id="target-audience"><h2>Target audience</h2></a>
<p>This book mainly targets to two audiences:</p>
<ul>
<li>
<p>People that wish to bootstrap bare metal support for an architecture that the ecosystem doesn't
yet support (e.g. Cortex-R as of Rust 1.28), or for an architecture that Rust just gained support
for (e.g. maybe Xtensa some time in the future).</p>
</li>
<li>
<p>People that are curious about the unusual implementation of <em>runtime</em> crates like <a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code></a>,
<a href="https://crates.io/crates/msp430-rt"><code>msp430-rt</code></a> and <a href="https://crates.io/crates/riscv-rt"><code>riscv-rt</code></a>.</p>
</li>
</ul>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<p>This book is self contained. The reader doesn't need to be familiar with the
Cortex-M architecture, nor is access to a Cortex-M microcontroller needed -- all
the examples included in this book can be tested in QEMU. You will, however,
need to install the following tools to run and inspect the examples in this
book:</p>
<ul>
<li>
<p>All the code in this book uses the 2018 edition. If you are not familiar with
the 2018 features and idioms check the <a href="https://rust-lang-nursery.github.io/edition-guide/"><code>edition guide</code></a>.</p>
</li>
<li>
<p>Rust 1.31 or a newer toolchain PLUS ARM Cortex-M compilation support.</p>
</li>
<li>
<p><a href="https://github.com/japaric/cargo-binutils"><code>cargo-binutils</code></a>. v0.1.4 or newer.</p>
</li>
<li>
<p><a href="https://crates.io/crates/cargo-edit"><code>cargo-edit</code></a>.</p>
</li>
<li>
<p>QEMU with support for ARM emulation. The <code>qemu-system-arm</code> program must be
installed on your computer.</p>
</li>
<li>
<p>GDB with ARM support.</p>
</li>
</ul>
<a class="header" href="#example-setup" id="example-setup"><h3>Example setup</h3></a>
<p>Instructions common to all OSes</p>
<pre><code class="language-console">$ # Rust toolchain
$ # If you start from scratch, get rustup from https://rustup.rs/
$ rustup default stable

$ # toolchain should be newer than this one
$ rustc -V
rustc 1.31.0 (abe02cefd 2018-12-04)

$ rustup target add thumbv7m-none-eabi

$ # cargo-binutils
$ cargo install cargo-binutils

$ rustup component add llvm-tools-preview

</code></pre>
<a class="header" href="#macos" id="macos"><h4>macOS</h4></a>
<pre><code class="language-console">$ # arm-none-eabi-gdb
$ # you may need to run `brew tap Caskroom/tap` first
$ brew cask install gcc-arm-embedded

$ # QEMU
$ brew install qemu
</code></pre>
<a class="header" href="#ubuntu-1604" id="ubuntu-1604"><h4>Ubuntu 16.04</h4></a>
<pre><code class="language-console">$ # arm-none-eabi-gdb
$ sudo apt install gdb-arm-none-eabi

$ # QEMU
$ sudo apt install qemu-system-arm
</code></pre>
<a class="header" href="#ubuntu-1804-or-debian" id="ubuntu-1804-or-debian"><h4>Ubuntu 18.04 or Debian</h4></a>
<pre><code class="language-console">$ # gdb-multiarch -- use `gdb-multiarch` when you wish to invoke gdb
$ sudo apt install gdb-multiarch

$ # QEMU
$ sudo apt install qemu-system-arm
</code></pre>
<a class="header" href="#windows" id="windows"><h4>Windows</h4></a>
<ul>
<li>
<p><a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">arm-none-eabi-gdb</a>.
The GNU Arm Embedded Toolchain includes GDB.</p>
</li>
<li>
<p><a href="https://www.qemu.org/download/#windows">QEMU</a></p>
</li>
</ul>
<a class="header" href="#installing-a-toolchain-bundle-from-arm-optional-step-tested-on-ubuntu-1804" id="installing-a-toolchain-bundle-from-arm-optional-step-tested-on-ubuntu-1804"><h2>Installing a toolchain bundle from ARM (optional step) (tested on Ubuntu 18.04)</h2></a>
<ul>
<li>With the late 2018 switch from
<a href="https://rust-embedded.github.io/blog/2018-08-2x-psa-cortex-m-breakage/">GCC's linker to LLD</a> for Cortex-M
microcontrollers, <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">gcc-arm-none-eabi</a> is no longer
required.  But for those wishing to use the toolchain
anyway, install from <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">here</a> and follow the steps outlined below:</li>
</ul>
<pre><code class="language-console">$ tar xvjf gcc-arm-none-eabi-8-2018-q4-major-linux.tar.bz2
$ mv gcc-arm-none-eabi-&lt;version_downloaded&gt; &lt;your_desired_path&gt; # optional
$ export PATH=${PATH}:&lt;path_to_arm_none_eabi_folder&gt;/bin # add this line to .bashrc to make persistent
</code></pre>
<a class="header" href="#the-smallest-no_std-program" id="the-smallest-no_std-program"><h1>The smallest <code>#![no_std]</code> program</h1></a>
<p>In this section we'll write the smallest <code>#![no_std]</code> program that <em>compiles</em>.</p>
<a class="header" href="#what-does-no_std-mean" id="what-does-no_std-mean"><h2>What does <code>#![no_std]</code> mean?</h2></a>
<p><code>#![no_std]</code> is a crate level attribute that indicates that the crate will link to the <a href="https://doc.rust-lang.org/core/"><code>core</code></a> crate
instead of the <a href="https://doc.rust-lang.org/std/"><code>std</code></a> crate, but what does this mean for applications?</p>
<p>The <code>std</code> crate is Rust's standard library. It contains functionality that assumes that the program
will run on an operating system rather than <a href="https://en.wikipedia.org/wiki/Bare_machine"><em>directly on the metal</em></a>. <code>std</code> also assumes that the
operating system is a general purpose operating system, like the ones one would find in servers and
desktops. For this reason, <code>std</code> provides a standard API over functionality one usually finds in
such operating systems: Threads, files, sockets, a filesystem, processes, etc.</p>
<p>On the other hand, the <code>core</code> crate is a subset of the <code>std</code> crate that makes zero assumptions about
the system the program will run on. As such, it provides APIs for language primitives like floats,
strings and slices, as well as APIs that expose processor features like atomic operations and SIMD
instructions. However it lacks APIs for anything that involves heap memory allocations and I/O.</p>
<p>For an application, <code>std</code> does more than just providing a way to access OS abstractions. <code>std</code> also
takes care of, among other things, setting up stack overflow protection, processing command line
arguments and spawning the main thread before a program's <code>main</code> function is invoked. A <code>#![no_std]</code>
application lacks all that standard runtime, so it must initialize its own runtime, if any is
required.</p>
<p>Because of these properties, a <code>#![no_std]</code> application can be the first and / or the only code that
runs on a system. It can be many things that a standard Rust application can never be, for example:</p>
<ul>
<li>The kernel of an OS.</li>
<li>Firmware.</li>
<li>A bootloader.</li>
</ul>
<a class="header" href="#the-code" id="the-code"><h2>The code</h2></a>
<p>With that out of the way, we can move on to the smallest <code>#![no_std]</code> program that compiles:</p>
<pre><code class="language-console">$ cargo new --edition 2018 --bin app

$ cd app
</code></pre>
<pre><code class="language-console">$ # modify main.rs so it has these contents
$ cat src/main.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_main]
#![no_std]

#fn main() {
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo&lt;'_&gt;) -&gt; ! {
    loop {}
}

#}</code></pre></pre>
<p>This program contains some things that you won't see in standard Rust programs:</p>
<p>The <code>#![no_std]</code> attribute which we have already extensively covered.</p>
<p>The <code>#![no_main]</code> attribute which means that the program won't use the standard <code>main</code> function as
its entry point. At the time of writing, Rust's <code>main</code> interface makes some assumptions about the
environment the program executes in: For example, it assumes the existence of command line
arguments, so in general, it's not appropriate for <code>#![no_std]</code> programs.</p>
<p>The <code>#[panic_handler]</code> attribute. The function marked with this attribute defines the behavior
of panics, both library level panics (<code>core::panic!</code>) and language level panics (out of bounds
indexing).</p>
<p>This program doesn't produce anything useful. In fact, it will produce an empty binary.</p>
<pre><code class="language-console">$ # equivalent to `size target/thumbv7m-none-eabi/debug/app`
$ cargo size --target thumbv7m-none-eabi --bin app
</code></pre>
<pre><code class="language-text">   text	   data	    bss	    dec	    hex	filename
      0	      0	      0	      0	      0	app

</code></pre>
<p>Before linking the crate does contain the panicking symbol.</p>
<pre><code class="language-console">$ cargo rustc --target thumbv7m-none-eabi -- --emit=obj

$ cargo nm -- target/thumbv7m-none-eabi/debug/deps/app-*.o | grep '[0-9]* [^N] '
</code></pre>
<pre><code class="language-text">00000000 T rust_begin_unwind

</code></pre>
<p>However, it's our starting point. In the next section, we'll build something useful. But before
continuing, let's set a default build target to avoid having to pass the <code>--target</code> flag to every
Cargo invocation.</p>
<pre><code class="language-console">$ mkdir .cargo

$ # modify .cargo/config so it has these contents
$ cat .cargo/config
</code></pre>
<pre><code class="language-toml">[build]
target = &quot;thumbv7m-none-eabi&quot;
</code></pre>
<a class="header" href="#memory-layout" id="memory-layout"><h1>Memory layout</h1></a>
<p>The next step is to ensure the program has the right memory layout so that the target system will be
able to execute it. In our example, we'll be working with a virtual Cortex-M3 microcontroller: the
<a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>. Our program will be the only process running on the device so it must also take care of
initializing the device.</p>
<a class="header" href="#background-information" id="background-information"><h2>Background information</h2></a>
<p>Cortex-M devices require a <a href="https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/exception-model/vector-table">vector table</a> to be present at the start of their <a href="https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/memory-model">code memory region</a>.
The vector table is an array of pointers; the first two pointers are required to boot the device;
the rest of pointers are related to exceptions -- we'll ignore them for now.</p>
<p>Linkers decide the final memory layout of programs, but we can use <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker scripts</a> to have some
control over it. The control granularity that linker scripts give us over the layout
is at the level of <em>sections</em>. A section is a collection of <em>symbols</em> laid out in contiguous memory.
Symbols, in turn, can be data (a static variable), or instructions (a Rust function).</p>
<p>Every symbol has a name assigned by the compiler. As of Rust 1.28 , the Rust compiler assigns to
symbols names of the form: <code>_ZN5krate6module8function17he1dfc17c86fe16daE</code>, which demangles to
<code>krate::module::function::he1dfc17c86fe16da</code> where <code>krate::module::function</code> is the path of the
function or variable and <code>he1dfc17c86fe16da</code> is some sort of hash. The Rust compiler will place each
symbol into its own and unique section; for example the symbol mentioned before will be placed in a
section named <code>.text._ZN5krate6module8function17he1dfc17c86fe16daE</code>.</p>
<p>These compiler generated symbol and section names are not guaranteed to remain constant across
different releases of the Rust compiler. However, the language lets us control symbol names and
section placement via these attributes:</p>
<ul>
<li><code>#[export_name = &quot;foo&quot;]</code> sets the symbol name to <code>foo</code>.</li>
<li><code>#[no_mangle]</code> means: use the function or variable name (not its full path) as its symbol name.
<code>#[no_mangle] fn bar()</code> will produce a symbol named <code>bar</code>.</li>
<li><code>#[link_section = &quot;.bar&quot;]</code> places the symbol in a section named <code>.bar</code>.</li>
</ul>
<p>With these attributes, we can expose a stable ABI of the program and use it in the linker script.</p>
<a class="header" href="#the-rust-side" id="the-rust-side"><h2>The Rust side</h2></a>
<p>Like mentioned before, for Cortex-M devices, we need to populate the first two entries of the
vector table. The first one, the initial value for the stack pointer, can be populated using
only the linker script. The second one, the reset vector, needs to be created in Rust code
and placed correctly using the linker script.</p>
<p>The reset vector is a pointer into the reset handler. The reset handler is the function that the
device will execute after a system reset, or after it powers up for the first time. The reset
handler is always the first stack frame in the hardware call stack; returning from it is undefined
behavior as there's no other stack frame to return to. We can enforce that the reset handler never
returns by making it a divergent function, which is a function with signature <code>fn(/* .. */) -&gt; !</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    let _x = 42;

    // can't return so we go into an infinite loop here
    loop {}
}

// The reset vector, a pointer into the reset handler
#[link_section = &quot;.vector_table.reset_vector&quot;]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern &quot;C&quot; fn() -&gt; ! = Reset;

#}</code></pre></pre>
<p>The hardware expects a certain format here, to which we adhere by using <code>extern &quot;C&quot;</code> to tell the
compiler to lower the function using the C ABI, instead of the Rust ABI, which is unstable.</p>
<p>To refer to the reset handler and reset vector from the linker script, we need them to have a stable
symbol name so we use <code>#[no_mangle]</code>. We need fine control over the location of <code>RESET_VECTOR</code>, so we
place it in a known section, <code>.vector_table.reset_vector</code>. The exact location of the reset handler
itself, <code>Reset</code>, is not important. We just stick to the default compiler generated section.</p>
<p>Also, the linker will ignore symbols with internal linkage, AKA internal symbols, while traversing
the list of input object files, so we need our two symbols to have external linkage. The only way to
make a symbol external in Rust is to make its corresponding item public (<code>pub</code>) and <em>reachable</em> (no
private module between the item and the root of the crate).</p>
<a class="header" href="#the-linker-script-side" id="the-linker-script-side"><h2>The linker script side</h2></a>
<p>Below is shown a minimal linker script that places the vector table in the right location. Let's
walk through it.</p>
<pre><code class="language-console">$ cat link.x
</code></pre>
<pre><code class="language-text">/* Memory layout of the LM3S6965 microcontroller */
/* 1K = 1 KiBi = 1024 bytes */
MEMORY
{
  FLASH : ORIGIN = 0x00000000, LENGTH = 256K
  RAM : ORIGIN = 0x20000000, LENGTH = 64K
}

/* The entry point is the reset handler */
ENTRY(Reset);

EXTERN(RESET_VECTOR);

SECTIONS
{
  .vector_table ORIGIN(FLASH) :
  {
    /* First entry: initial Stack Pointer value */
    LONG(ORIGIN(RAM) + LENGTH(RAM));

    /* Second entry: reset vector */
    KEEP(*(.vector_table.reset_vector));
  } &gt; FLASH

  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /DISCARD/ :
  {
    *(.ARM.exidx .ARM.exidx.*);
  }
}

</code></pre>
<a class="header" href="#memory" id="memory"><h3><code>MEMORY</code></h3></a>
<p>This section of the linker script describes the location and size of blocks of memory in the target.
Two memory blocks are defined: <code>FLASH</code> and <code>RAM</code>; they correspond to the physical memory available
in the target. The values used here correspond to the LM3S6965 microcontroller.</p>
<a class="header" href="#entry" id="entry"><h3><code>ENTRY</code></h3></a>
<p>Here we indicate to the linker that the reset handler -- whose symbol name is <code>Reset</code> -- is the
<em>entry point</em> of the program. Linkers aggressively discard unused sections. Linkers consider the
entry point and functions called from it as <em>used</em> so they won't discard them. Without this line,
the linker would discard the <code>Reset</code> function and all subsequent functions called from it.</p>
<a class="header" href="#extern" id="extern"><h3><code>EXTERN</code></h3></a>
<p>Linkers are lazy; they will stop looking into the input object files once they have found all the
symbols that are recursively referenced from the entry point. <code>EXTERN</code> forces the linker to look
for <code>EXTERN</code>'s argument even after all other referenced symbols have been found. As a rule of thumb,
if you need a symbol that's not called from the entry point to always be present in the output binary,
you should use <code>EXTERN</code> in conjunction with <code>KEEP</code>.</p>
<a class="header" href="#sections" id="sections"><h3><code>SECTIONS</code></h3></a>
<p>This part describes how sections in the input object files, AKA <em>input sections</em>, are to be arranged
in the sections of the output object file, AKA output sections; or if they should be discarded. Here
we define two output sections:</p>
<pre><code class="language-text">  .vector_table ORIGIN(FLASH) : { /* .. */ } &gt; FLASH
</code></pre>
<p><code>.vector_table</code>, which contains the vector table and is located at the start of <code>FLASH</code> memory,</p>
<pre><code class="language-text">  .text : { /* .. */ } &gt; FLASH
</code></pre>
<p>and <code>.text</code>, which contains the program subroutines and is located somewhere in <code>FLASH</code>. Its start
address is not specified, but the linker will place it after the previous output section,
<code>.vector_table</code>.</p>
<p>The output <code>.vector_table</code> section contains:</p>
<pre><code class="language-text">    /* First entry: initial Stack Pointer value */
    LONG(ORIGIN(RAM) + LENGTH(RAM));
</code></pre>
<p>We'll place the (call) stack at the end of RAM (the stack is <em>full descending</em>; it grows towards
smaller addresses) so the end address of RAM will be used as the initial Stack Pointer (SP) value.
That address is computed in the linker script itself using the information we entered for the <code>RAM</code>
memory block.</p>
<pre><code>    /* Second entry: reset vector */
    KEEP(*(.vector_table.reset_vector));
</code></pre>
<p>Next, we use <code>KEEP</code> to force the linker to insert all input sections named
<code>.vector_table.reset_vector</code> right after the initial SP value. The only symbol located in that
section is <code>RESET_VECTOR</code>, so this will effectively place <code>RESET_VECTOR</code> second in the vector table.</p>
<p>The output <code>.text</code> section contains:</p>
<pre><code class="language-text">    *(.text .text.*);
</code></pre>
<p>This includes all the input sections named <code>.text</code> and <code>.text.*</code>. Note that we don't use <code>KEEP</code>
here to let the linker discard unused sections.</p>
<p>Finally, we use the special <code>/DISCARD/</code> section to discard</p>
<pre><code class="language-text">    *(.ARM.exidx .ARM.exidx.*);
</code></pre>
<p>input sections named <code>.ARM.exidx.*</code>. These sections are related to exception handling but we are not
doing stack unwinding on panics and they take up space in Flash memory, so we just discard them.</p>
<a class="header" href="#putting-it-all-together" id="putting-it-all-together"><h2>Putting it all together</h2></a>
<p>Now we can link the application. For reference, here's the complete Rust program:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_main]
#![no_std]

#fn main() {
use core::panic::PanicInfo;

// The reset handler
#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    let _x = 42;

    // can't return so we go into an infinite loop here
    loop {}
}

// The reset vector, a pointer into the reset handler
#[link_section = &quot;.vector_table.reset_vector&quot;]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern &quot;C&quot; fn() -&gt; ! = Reset;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo&lt;'_&gt;) -&gt; ! {
    loop {}
}

#}</code></pre></pre>
<p>We have to tweak linker process to make it use our linker script. This is done
passing the <code>-C link-arg</code> flag to <code>rustc</code> but there are two ways to do it: you
can use the <code>cargo-rustc</code> subcommand instead of <code>cargo-build</code> as shown below:</p>
<p><strong>IMPORTANT</strong>: Make sure you have the <code>.cargo/config</code> file that was added at the
end of the last section before running this command.</p>
<pre><code class="language-console">$ cargo rustc -- -C link-arg=-Tlink.x
</code></pre>
<p>Or you can set the rustflags in <code>.cargo/config</code> and continue using the
<code>cargo-build</code> subcommand. We'll do the latter because it better integrates with
<code>cargo-binutils</code>.</p>
<pre><code class="language-console"># modify .cargo/config so it has these contents
$ cat .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]

[build]
target = &quot;thumbv7m-none-eabi&quot;
</code></pre>
<p>The <code>[target.thumbv7m-none-eabi]</code> part says that these flags will only be used
when cross compiling to that target.</p>
<a class="header" href="#inspecting-it" id="inspecting-it"><h2>Inspecting it</h2></a>
<p>Now let's inspect the output binary to confirm the memory layout looks the way we want:</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -d -no-show-raw-insn
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little


Disassembly of section .text:

Reset:
                sub	sp, #4
                movs	r0, #42
                str	r0, [sp]
                b	#-2 &lt;Reset+0x8&gt;
                b	#-4 &lt;Reset+0x8&gt;

</code></pre>
<p>This is the disassembly of the <code>.text</code> section. We see that the reset handler, named <code>Reset</code>, is
located at address <code>0x8</code>.</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -s -section .vector_table
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little

Contents of section .vector_table:
 0000 00000120 09000000                    ... ....

</code></pre>
<p>This shows the contents of the <code>.vector_table</code> section. We can see that the section starts at
address <code>0x0</code> and that the first word of the section is <code>0x2001_0000</code> (the <code>objdump</code> output is in
little endian format). This is the initial SP value and matches the end address of RAM. The second
word is <code>0x9</code>; this is the <em>thumb mode</em> address of the reset handler. When a function is to be
executed in thumb mode the first bit of its address is set to 1.</p>
<a class="header" href="#testing-it" id="testing-it"><h2>Testing it</h2></a>
<p>This program is a valid LM3S6965 program; we can execute it in a virtual microcontroller (QEMU) to
test it out.</p>
<pre><code class="language-console">$ # this program will block
$ qemu-system-arm \
      -cpu cortex-m3 \
      -machine lm3s6965evb \
      -gdb tcp::3333 \
      -S \
      -nographic \
      -kernel target/thumbv7m-none-eabi/debug/app
</code></pre>
<pre><code class="language-console">$ # on a different terminal
$ arm-none-eabi-gdb -q target/thumbv7m-none-eabi/debug/app
Reading symbols from target/thumbv7m-none-eabi/debug/app...done.

(gdb) target remote :3333
Remote debugging using :3333
Reset () at src/main.rs:8
8       pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {

(gdb) # the SP has the initial value we programmed in the vector table
(gdb) print/x $sp
$1 = 0x20010000

(gdb) step
9           let _x = 42;

(gdb) step
12          loop {}

(gdb) # next we inspect the stack variable `_x`
(gdb) print _x
$2 = 42

(gdb) print &amp;_x
$3 = (i32 *) 0x2000fffc

(gdb) quit
</code></pre>
<a class="header" href="#a-main-interface" id="a-main-interface"><h1>A <code>main</code> interface</h1></a>
<p>We have a minimal working program now, but we need to package it in a way that the end user can build
safe programs on top of it. In this section, we'll implement a <code>main</code> interface like the one standard
Rust programs use.</p>
<p>First, we'll convert our binary crate into a library crate:</p>
<pre><code class="language-console">$ mv src/main.rs src/lib.rs
</code></pre>
<p>And then rename it to <code>rt</code> which stands for &quot;runtime&quot;.</p>
<pre><code class="language-console">$ sed -i s/app/rt/ Cargo.toml

$ head -n4 Cargo.toml
</code></pre>
<pre><code class="language-toml">[package]
edition = &quot;2018&quot;
name = &quot;rt&quot; # &lt;-
version = &quot;0.1.0&quot;
</code></pre>
<p>The first change is to have the reset handler call an external <code>main</code> function:</p>
<pre><code class="language-console">$ head -n13 src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_std]

use core::panic::PanicInfo;

// CHANGED!
#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    extern &quot;Rust&quot; {
        fn main() -&gt; !;
    }

    main()
}
</code></pre></pre>
<p>We also drop the <code>#![no_main]</code> attribute as it has no effect on library crates.</p>
<blockquote>
<p>There's an orthogonal question that arises at this stage: Should the <code>rt</code>
library provide a standard panicking behavior, or should it <em>not</em> provide a
<code>#[panic_handler]</code> function and leave the end user choose the panicking
behavior? This document won't delve into that question and for simplicity will
leave the dummy <code>#[panic_handler]</code> function in the <code>rt</code> crate. However, we
wanted to inform the reader that there are other options.</p>
</blockquote>
<p>The second change involves providing the linker script we wrote before to the application crate. You
see the linker will search for linker scripts in the library search path (<code>-L</code>) and in the directory
from which it's invoked. The application crate shouldn't need to carry around a copy of <code>link.x</code> so
we'll have the <code>rt</code> crate put the linker script in the library search path using a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>.</p>
<pre><code class="language-console">$ # create a build.rs file in the root of `rt` with these contents
$ cat build.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">use std::{env, error::Error, fs::File, io::Write, path::PathBuf};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // build directory for this crate
    let out_dir = PathBuf::from(env::var_os(&quot;OUT_DIR&quot;).unwrap());

    // extend the library search path
    println!(&quot;cargo:rustc-link-search={}&quot;, out_dir.display());

    // put `link.x` in the build directory
    File::create(out_dir.join(&quot;link.x&quot;))?.write_all(include_bytes!(&quot;link.x&quot;))?;

    Ok(())
}

</code></pre></pre>
<p>Now the user can write an application that exposes the <code>main</code> symbol and link it to the <code>rt</code> crate.
The <code>rt</code> will take care of giving the program the right memory layout.</p>
<pre><code class="language-console">$ cd ..

$ cargo new --edition 2018 --bin app

$ cd app

$ # modify Cargo.toml to include the `rt` crate as a dependency
$ tail -n2 Cargo.toml
</code></pre>
<pre><code class="language-toml">[dependencies]
rt = { path = &quot;../rt&quot; }
</code></pre>
<pre><code class="language-console">$ # copy over the config file that sets a default target and tweaks the linker invocation
$ cp -r ../rt/.cargo .

$ # change the contents of `main.rs` to
$ cat src/main.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_std]
#![no_main]

extern crate rt;

#[no_mangle]
pub fn main() -&gt; ! {
    let _x = 42;

    loop {}
}

</code></pre></pre>
<p>The disassembly will be similar but will now include the user <code>main</code> function.</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -d -no-show-raw-insn
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little


Disassembly of section .text:

main:
                sub	sp, #4
                movs	r0, #42
                str	r0, [sp]
                b	#-2 &lt;main+0x8&gt;
                b	#-4 &lt;main+0x8&gt;

Reset:
                bl	#-14
                trap

</code></pre>
<a class="header" href="#making-it-type-safe" id="making-it-type-safe"><h2>Making it type safe</h2></a>
<p>The <code>main</code> interface works, but it's easy to get it wrong: For example, the user could write <code>main</code>
as a non-divergent function, and they would get no compile time error and undefined behavior (the
compiler will misoptimize the program).</p>
<p>We can add type safety by exposing a macro to the user instead of the symbol interface. In the
<code>rt</code> crate, we can write this macro:</p>
<pre><code class="language-console">$ tail -n12 ../rt/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! entry {
    ($path:path) =&gt; {
        #[export_name = &quot;main&quot;]
        pub unsafe fn __main() -&gt; ! {
            // type check the given path
            let f: fn() -&gt; ! = $path;

            f()
        }
    }
}
#}</code></pre></pre>
<p>Then the application writers can invoke it like this:</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_std]
#![no_main]

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    let _x = 42;

    loop {}
}

</code></pre></pre>
<p>Now the author will get an error if they change the signature of <code>main</code> to be
non divergent function, e.g. <code>fn()</code>.</p>
<a class="header" href="#life-before-main" id="life-before-main"><h2>Life before main</h2></a>
<p><code>rt</code> is looking good but it's not feature complete! Applications written against it can't use
<code>static</code> variables or string literals because <code>rt</code>'s linker script doesn't define the standard
<code>.bss</code>, <code>.data</code> and <code>.rodata</code> sections. Let's fix that!</p>
<p>The first step is to define these sections in the linker script:</p>
<pre><code class="language-console">$ # showing just a fragment of the file
$ sed -n 25,46p ../rt/link.x
</code></pre>
<pre><code class="language-text">  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /* NEW! */
  .rodata :
  {
    *(.rodata .rodata.*);
  } &gt; FLASH

  .bss :
  {
    *(.bss .bss.*);
  } &gt; RAM

  .data :
  {
    *(.data .data.*);
  } &gt; RAM

  /DISCARD/ :
</code></pre>
<p>They just re-export the input sections and specify in which memory region each output section will
go.</p>
<p>With these changes, the following program will compile:</p>
<pre><pre class="playpen"><code class="language-rust">#![no_std]
#![no_main]

use rt::entry;

entry!(main);

static RODATA: &amp;[u8] = b&quot;Hello, world!&quot;;
static mut BSS: u8 = 0;
static mut DATA: u16 = 1;

fn main() -&gt; ! {
    let _x = RODATA;
    let _y = unsafe { &amp;BSS };
    let _z = unsafe { &amp;DATA };

    loop {}
}

</code></pre></pre>
<p>However if you run this program on real hardware and debug it, you'll observe that the <code>static</code>
variables <code>BSS</code> and <code>DATA</code> don't have the values <code>0</code> and <code>1</code> by the time <code>main</code> has been reached.
Instead, these variables will have junk values. The problem is that the contents of RAM are
random after powering up the device. You won't be able to observe this effect if you run the
program in QEMU.</p>
<p>As things stand if your program reads any <code>static</code> variable before performing a write to it then
your program has undefined behavior. Let's fix that by initializing all <code>static</code> variables before
calling <code>main</code>.</p>
<p>We'll need to tweak the linker script a bit more to do the RAM initialization:</p>
<pre><code class="language-console">$ # showing just a fragment of the file
$ sed -n 25,52p ../rt/link.x
</code></pre>
<pre><code class="language-text">  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /* CHANGED! */
  .rodata :
  {
    *(.rodata .rodata.*);
  } &gt; FLASH

  .bss :
  {
    _sbss = .;
    *(.bss .bss.*);
    _ebss = .;
  } &gt; RAM

  .data : AT(ADDR(.rodata) + SIZEOF(.rodata))
  {
    _sdata = .;
    *(.data .data.*);
    _edata = .;
  } &gt; RAM

  _sidata = LOADADDR(.data);

  /DISCARD/ :
</code></pre>
<p>Let's go into the details of these changes:</p>
<pre><code class="language-text">    _sbss = .;
</code></pre>
<pre><code class="language-text">    _ebss = .;
</code></pre>
<pre><code class="language-text">    _sdata = .;
</code></pre>
<pre><code class="language-text">    _edata = .;
</code></pre>
<p>We associate symbols to the start and end addresses of the <code>.bss</code> and <code>.data</code> sections, which we'll
later use from Rust code.</p>
<pre><code class="language-text">  .data : AT(ADDR(.rodata) + SIZEOF(.rodata))
</code></pre>
<p>We set the Load Memory Address (LMA) of the <code>.data</code> section to the end of the <code>.rodata</code>
section. The <code>.data</code> contains <code>static</code> variables with a non-zero initial value; the Virtual Memory
Address (VMA) of the <code>.data</code> section is somewhere in RAM -- this is where the <code>static</code> variables are
located. The initial values of those <code>static</code> variables, however, must be allocated in non volatile
memory (Flash); the LMA is where in Flash those initial values are stored.</p>
<pre><code class="language-text">  _sidata = LOADADDR(.data);
</code></pre>
<p>Finally, we associate a symbol to the LMA of <code>.data</code>.</p>
<p>On the Rust side, we zero the <code>.bss</code> section and initialize the <code>.data</code> section. We can reference
the symbols we created in the linker script from the Rust code. The <em>addresses</em><sup class="footnote-reference"><a href="#1">1</a></sup> of these symbols are
the boundaries of the <code>.bss</code> and <code>.data</code> sections.</p>
<p>The updated reset handler is shown below:</p>
<pre><code class="language-console">$ head -n32 ../rt/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_std]

use core::panic::PanicInfo;
use core::ptr;

#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    // NEW!
    // Initialize RAM
    extern &quot;C&quot; {
        static mut _sbss: u8;
        static mut _ebss: u8;

        static mut _sdata: u8;
        static mut _edata: u8;
        static _sidata: u8;
    }

    let count = &amp;_ebss as *const u8 as usize - &amp;_sbss as *const u8 as usize;
    ptr::write_bytes(&amp;mut _sbss as *mut u8, 0, count);

    let count = &amp;_edata as *const u8 as usize - &amp;_sdata as *const u8 as usize;
    ptr::copy_nonoverlapping(&amp;_sidata as *const u8, &amp;mut _sdata as *mut u8, count);

    // Call user entry point
    extern &quot;Rust&quot; {
        fn main() -&gt; !;
    }

    main()
}
</code></pre></pre>
<p>Now end users can directly and indirectly make use of <code>static</code> variables without running into
undefined behavior!</p>
<blockquote>
<p>In the code above we performed the memory initialization in a bytewise fashion. It's possible to
force the <code>.bss</code> and <code>.data</code> sections to be aligned to, say, 4 bytes. This fact can then be used
in the Rust code to perform the initialization wordwise while omitting alignment checks. If you
are interested in learning how this can be achieved check the <a href="https://github.com/japaric/cortex-m-rt/tree/v0.5.1"><code>cortex-m-rt</code></a> crate.</p>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The fact that the addresses of the linker script symbols must be used here can be confusing and
unintuitive. An elaborate explanation for this oddity can be found <a href="https://stackoverflow.com/a/40392131">here</a>.</p>
</div>
<a class="header" href="#exception-handling" id="exception-handling"><h1>Exception handling</h1></a>
<p>During the &quot;Memory layout&quot; section, we decided to start out simple and leave out handling of
exceptions. In this section, we'll add support for handling them; this serves as an example of
how to achieve compile time overridable behavior in stable Rust (i.e. without relying on the
unstable <code>#[linkage = &quot;weak&quot;]</code> attribute, which makes a symbol weak).</p>
<a class="header" href="#background-information-1" id="background-information-1"><h2>Background information</h2></a>
<p>In a nutshell, <em>exceptions</em> are a mechanism the Cortex-M and other architectures provide to let
applications respond to asynchronous, usually external, events. The most prominent type of exception,
that most people will know, is the classical (hardware) interrupt.</p>
<p>The Cortex-M exception mechanism works like this:
When the processor receives a signal or event associated to a type of exception, it suspends
the execution of the current subroutine (by stashing the state in the call stack) and then proceeds
to execute the corresponding exception handler, another subroutine, in a new stack frame. After
finishing the execution of the exception handler (i.e. returning from it), the processor resumes the
execution of the suspended subroutine.</p>
<p>The processor uses the vector table to decide what handler to execute. Each entry in the table
contains a pointer to a handler, and each entry corresponds to a different exception type. For
example, the second entry is the reset handler, the third entry is the NMI (Non Maskable Interrupt)
handler, and so on.</p>
<p>As mentioned before, the processor expects the vector table to be at some specific location in memory,
and each entry in it can potentially be used by the processor at runtime. Hence, the entries must always
contain valid values. Furthermore, we want the <code>rt</code> crate to be flexible so the end user can customize the
behavior of each exception handler. Finally, the vector table resides in read only memory, or rather in not
easily modified memory, so the user has to register the handler statically, rather than at runtime.</p>
<p>To satisfy all these constraints, we'll assign a <em>default</em> value to all the entries of the vector
table in the <code>rt</code> crate, but make these values kind of <em>weak</em> to let the end user override them
at compile time.</p>
<a class="header" href="#rust-side" id="rust-side"><h2>Rust side</h2></a>
<p>Let's see how all this can be implemented. For simplicity, we'll only work with the first 16 entries
of the vector table; these entries are not device specific so they have the same function on any
kind of Cortex-M microcontroller.</p>
<p>The first thing we'll do is create an array of vectors (pointers to exception handlers) in the
<code>rt</code> crate's code:</p>
<pre><code class="language-console">$ sed -n 56,91p ../rt/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub union Vector {
    reserved: u32,
    handler: unsafe extern &quot;C&quot; fn(),
}

extern &quot;C&quot; {
    fn NMI();
    fn HardFault();
    fn MemManage();
    fn BusFault();
    fn UsageFault();
    fn SVCall();
    fn PendSV();
    fn SysTick();
}

#[link_section = &quot;.vector_table.exceptions&quot;]
#[no_mangle]
pub static EXCEPTIONS: [Vector; 14] = [
    Vector { handler: NMI },
    Vector { handler: HardFault },
    Vector { handler: MemManage },
    Vector { handler: BusFault },
    Vector {
        handler: UsageFault,
    },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: SVCall },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: PendSV },
    Vector { handler: SysTick },
];
#}</code></pre></pre>
<p>Some of the entries in the vector table are <em>reserved</em>; the ARM documentation states that they
should be assigned the value <code>0</code> so we use a union to do exactly that. The entries that must point
to a handler make use of <em>external</em> functions; this is important because it lets the end user
<em>provide</em> the actual function definition.</p>
<p>Next, we define a default exception handler in the Rust code. Exceptions that have not been assigned
a handler by the end user will make use of this default handler.</p>
<pre><code class="language-console">$ tail -n4 ../rt/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn DefaultExceptionHandler() {
    loop {}
}
#}</code></pre></pre>
<a class="header" href="#linker-script-side" id="linker-script-side"><h2>Linker script side</h2></a>
<p>On the linker script side, we place these new exception vectors right after the reset vector.</p>
<pre><code class="language-console">$ sed -n 12,25p ../rt/link.x
</code></pre>
<pre><code class="language-text">EXTERN(RESET_VECTOR);
EXTERN(EXCEPTIONS); /* &lt;- NEW */

SECTIONS
{
  .vector_table ORIGIN(FLASH) :
  {
    /* First entry: initial Stack Pointer value */
    LONG(ORIGIN(RAM) + LENGTH(RAM));

    /* Second entry: reset vector */
    KEEP(*(.vector_table.reset_vector));

    /* The next 14 entries are exception vectors */
    KEEP(*(.vector_table.exceptions)); /* &lt;- NEW */
  } &gt; FLASH
</code></pre>
<p>And we use <code>PROVIDE</code> to give a default value to the handlers that we left undefined in <code>rt</code> (<code>NMI</code>
and the others above):</p>
<pre><code class="language-console">$ tail -n8 ../rt/link.x
</code></pre>
<pre><code class="language-text">PROVIDE(NMI = DefaultExceptionHandler);
PROVIDE(HardFault = DefaultExceptionHandler);
PROVIDE(MemManage = DefaultExceptionHandler);
PROVIDE(BusFault = DefaultExceptionHandler);
PROVIDE(UsageFault = DefaultExceptionHandler);
PROVIDE(SVCall = DefaultExceptionHandler);
PROVIDE(PendSV = DefaultExceptionHandler);
PROVIDE(SysTick = DefaultExceptionHandler);
</code></pre>
<p><code>PROVIDE</code> only takes effect when the symbol to the left of the equal sign is still undefined after
inspecting all the input object files. This is the scenario where the user didn't implement the
handler for the respective exception.</p>
<a class="header" href="#testing-it-1" id="testing-it-1"><h2>Testing it</h2></a>
<p>That's it! The <code>rt</code> crate now has support for exception handlers. We can test it out with following
application:</p>
<blockquote>
<p><strong>NOTE</strong>: Turns out it's hard to generate an exception in QEMU. On real
hardware a read to an invalid memory address (i.e. outside of the Flash and
RAM regions) would be enough but QEMU happily accepts the operation and
returns zero. A trap instruction works on both QEMU and hardware but
unfortunately it's not available on stable so you'll have to temporarily
switch to nightly to run this and the next example.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">#![feature(core_intrinsics)]
#![no_main]
#![no_std]

use core::intrinsics;

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    // this executes the undefined instruction (UDF) and causes a HardFault exception
    unsafe { intrinsics::abort() }
}

</code></pre></pre>
<pre><code class="language-console">(gdb) target remote :3333
Remote debugging using :3333
Reset () at ../rt/src/lib.rs:7
7       pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {

(gdb) b DefaultExceptionHandler
Breakpoint 1 at 0xec: file ../rt/src/lib.rs, line 95.

(gdb) continue
Continuing.

Breakpoint 1, DefaultExceptionHandler ()
    at ../rt/src/lib.rs:95
95          loop {}

(gdb) list
90          Vector { handler: SysTick },
91      ];
92
93      #[no_mangle]
94      pub extern &quot;C&quot; fn DefaultExceptionHandler() {
95          loop {}
96      }
</code></pre>
<p>And for completeness, here's the disassembly of the optimized version of the program:</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -d -no-show-raw-insn -print-imm-hex
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little


Disassembly of section .text:

main:
                trap
                trap

Reset:
                movw	r1, #0x0
                movw	r0, #0x0
                movt	r1, #0x2000
                movt	r0, #0x2000
                subs	r1, r1, r0
                bl	#0xe2
                movw	r1, #0x0
                movw	r0, #0x0
                movt	r1, #0x2000
                movt	r0, #0x2000
                subs	r2, r1, r0
                movw	r1, #0x142
                movt	r1, #0x0
                bl	#0x8
                bl	#-0x3c
                trap

DefaultExceptionHandler:
                b	#-0x4 &lt;DefaultExceptionHandler&gt;
</code></pre>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -s -j .vector_table
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little

Contents of section .vector_table:
 0000 00000120 45000000 7f000000 7f000000  ... E...........
 0010 7f000000 7f000000 7f000000 00000000  ................
 0020 00000000 00000000 00000000 7f000000  ................
 0030 00000000 00000000 7f000000 7f000000  ................

</code></pre>
<p>The vector table now resembles the results of all the code snippets in this book
so far. To summarize:</p>
<ul>
<li>In the <a href="https://docs.rust-embedded.org/embedonomicon/memory-layout.html#inspecting-it"><em>Inspecting it</em></a> section of the earlier memory chapter, we learned
that:
<ul>
<li>The first entry in the vector table contains the initial value of the
stack pointer.</li>
<li>Objdump prints in <code>little endian</code> format, so the stack starts at
<code>0x2001_0000</code>.</li>
<li>The second entry points to address <code>0x0000_0045</code>, the Reset handler.
<ul>
<li>The address of the Reset handler can be seen in the disassembly above,
being <code>0x44</code>.</li>
<li>The first bit being set to 1 does not alter the address due to
alignment requirements. Instead, it causes the function to be executed
in <em>thumb mode</em>.</li>
</ul>
</li>
</ul>
</li>
<li>Afterwards, a pattern of addresses alternating between <code>0x7f</code> and <code>0x00</code> is
visible.
<ul>
<li>Looking at the disassembly above, it is clear that <code>0x7f</code> refers to the
<code>DefaultExceptionHandler</code> (<code>0x7e</code> executed in thumb mode).</li>
<li>Cross referencing the pattern to the vector table that was set up earlier
in this chapter (see the definition of <code>pub static EXCEPTIONS</code>) with <a href="https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/exception-model/vector-table">the
vector table layout for the Cortex-M</a>, it is clear that the address of the
<code>DefaultExceptionHandler</code> is present each time a respective handler entry
is present in the table.</li>
<li>In turn, it is also visible that the layout of the vector table data
structure in the Rust code is aligned with all the reserved slots in the
Cortex-M vector table. Hence, all reserved slots are correctly set to a
value of zero.</li>
</ul>
</li>
</ul>
<a class="header" href="#overriding-a-handler" id="overriding-a-handler"><h2>Overriding a handler</h2></a>
<p>To override an exception handler, the user has to provide a function whose symbol name exactly
matches the name we used in <code>EXCEPTIONS</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(core_intrinsics)]
#![no_main]
#![no_std]

use core::intrinsics;

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    unsafe { intrinsics::abort() }
}

#[no_mangle]
pub extern &quot;C&quot; fn HardFault() -&gt; ! {
    // do something interesting here
    loop {}
}

</code></pre></pre>
<p>You can test it in QEMU</p>
<pre><code class="language-console">(gdb) target remote :3333
Remote debugging using :3333
Reset () at /home/japaric/rust/embedonomicon/ci/exceptions/rt/src/lib.rs:7
7       pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {

(gdb) b HardFault
Breakpoint 1 at 0x44: file src/main.rs, line 18.

(gdb) continue
Continuing.

Breakpoint 1, HardFault () at src/main.rs:18
18          loop {}

(gdb) list
13      }
14
15      #[no_mangle]
16      pub extern &quot;C&quot; fn HardFault() -&gt; ! {
17          // do something interesting here
18          loop {}
19      }
</code></pre>
<p>The program now executes the user defined <code>HardFault</code> function instead of the
<code>DefaultExceptionHandler</code> in the <code>rt</code> crate.</p>
<p>Like our first attempt at a <code>main</code> interface, this first implementation has the problem of having no
type safety. It's also easy to mistype the name of the exception, but that doesn't produce an error
or warning. Instead the user defined handler is simply ignored. Those problems can be fixed using a
macro like the <a href="https://github.com/japaric/cortex-m-rt/blob/v0.5.1/src/lib.rs#L792"><code>exception!</code></a> macro defined in <code>cortex-m-rt</code> v0.5.x or the
<a href="https://github.com/rust-embedded/cortex-m-rt/blob/v0.6.3/macros/src/lib.rs#L254"><code>exception</code></a> attribute in <code>cortex-m-rt</code> v0.6.x.</p>
<a class="header" href="#assembly-on-stable" id="assembly-on-stable"><h1>Assembly on stable</h1></a>
<p>So far we have managed to boot the device and handle interrupts without a single
line of assembly. That's quite a feat! But depending on the architecture you are
targeting you may need some assembly to get to this point. There are also some
operations like context switching that require assembly, etc.</p>
<p>The problem is that both <em>inline</em> assembly (<code>asm!</code>) and <em>free form</em> assembly
(<code>global_asm!</code>) are unstable, and there's no estimate for when they'll be
stabilized, so you can't use them on stable . This is not a showstopper because
there are some workarounds which we'll document here.</p>
<p>To motivate this section we'll tweak the <code>HardFault</code> handler to provide
information about the stack frame that generated the exception.</p>
<p>Here's what we want to do:</p>
<p>Instead of letting the user directly put their <code>HardFault</code> handler in the vector
table we'll make the <code>rt</code> crate put a trampoline to the user-defined <code>HardFault</code>
handler in the vector table.</p>
<pre><code class="language-console">$ tail -n36 ../rt/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern &quot;C&quot; {
    fn NMI();
    fn HardFaultTrampoline(); // &lt;- CHANGED!
    fn MemManage();
    fn BusFault();
    fn UsageFault();
    fn SVCall();
    fn PendSV();
    fn SysTick();
}

#[link_section = &quot;.vector_table.exceptions&quot;]
#[no_mangle]
pub static EXCEPTIONS: [Vector; 14] = [
    Vector { handler: NMI },
    Vector { handler: HardFaultTrampoline }, // &lt;- CHANGED!
    Vector { handler: MemManage },
    Vector { handler: BusFault },
    Vector {
        handler: UsageFault,
    },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: SVCall },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: PendSV },
    Vector { handler: SysTick },
];

#[no_mangle]
pub extern &quot;C&quot; fn DefaultExceptionHandler() {
    loop {}
}
#}</code></pre></pre>
<p>This trampoline will read the stack pointer and then call the user <code>HardFault</code>
handler. The trampoline will have to be written in assembly:</p>
<pre><code class="language-armasm">  mrs r0, MSP
  b HardFault
</code></pre>
<p>Due to how the ARM ABI works this sets the Main Stack Pointer (MSP) as the first
argument of the <code>HardFault</code> function / routine. This MSP value also happens to
be a pointer to the registers pushed to the stack by the exception. With these
changes the user <code>HardFault</code> handler must now have signature
<code>fn(&amp;StackedRegisters) -&gt; !</code>.</p>
<a class="header" href="#s-files" id="s-files"><h2><code>.s</code> files</h2></a>
<p>One approach to stable assembly is to write the assembly in an external file:</p>
<pre><code class="language-console">$ cat ../rt/asm.s
</code></pre>
<pre><code class="language-armasm">  .section .text.HardFaultTrampoline
  .global HardFaultTrampoline
  .thumb_func
HardFaultTrampoline:
  mrs r0, MSP
  b HardFault

</code></pre>
<p>And use the <code>cc</code> crate in the build script of the <code>rt</code> crate to assemble that
file into an object file (<code>.o</code>) and then into an archive (<code>.a</code>).</p>
<pre><code class="language-console">$ cat ../rt/build.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">use std::{env, error::Error, fs::File, io::Write, path::PathBuf};

use cc::Build;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // build directory for this crate
    let out_dir = PathBuf::from(env::var_os(&quot;OUT_DIR&quot;).unwrap());

    // extend the library search path
    println!(&quot;cargo:rustc-link-search={}&quot;, out_dir.display());

    // put `link.x` in the build directory
    File::create(out_dir.join(&quot;link.x&quot;))?.write_all(include_bytes!(&quot;link.x&quot;))?;

    // assemble the `asm.s` file
    Build::new().file(&quot;asm.s&quot;).compile(&quot;asm&quot;); // &lt;- NEW!

    // rebuild if `asm.s` changed
    println!(&quot;cargo:rerun-if-changed=asm.s&quot;); // &lt;- NEW!

    Ok(())
}

</code></pre></pre>
<pre><code class="language-console">$ tail -n2 ../rt/Cargo.toml
</code></pre>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.25&quot;
</code></pre>
<p>And that's it!</p>
<p>We can confirm that the vector table contains a pointer to <code>HardFaultTrampoline</code>
by writing a very simple program.</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    loop {}
}

#[allow(non_snake_case)]
#[no_mangle]
pub fn HardFault(_ef: *const u32) -&gt; ! {
    loop {}
}

</code></pre></pre>
<p>Here's the disassembly. Look at the address of <code>HardFaultTrampoline</code>.</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -d -no-show-raw-insn -print-imm-hex
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little


Disassembly of section .text:

HardFault:
                b	#-0x4 &lt;HardFault&gt;

main:
                trap

Reset:
                bl	#-0x6
                trap

DefaultExceptionHandler:
                b	#-0x4 &lt;DefaultExceptionHandler&gt;

UsageFault:
                &lt;unknown&gt;

HardFaultTrampoline:
                mrs	r0, msp
                b	#-0x14 &lt;HardFault&gt;

</code></pre>
<blockquote>
<p><strong>NOTE:</strong> To make this disassembly smaller I commented out the initialization
of RAM</p>
</blockquote>
<p>Now look at the vector table. The 4th entry should be the address of
<code>HardFaultTrampoline</code> plus one.</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -s -j .vector_table
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little

Contents of section .vector_table:
 0000 00000120 45000000 4b000000 4d000000  ... E...K...M...
 0010 4b000000 4b000000 4b000000 00000000  K...K...K.......
 0020 00000000 00000000 00000000 4b000000  ............K...
 0030 00000000 00000000 4b000000 4b000000  ........K...K...

</code></pre>
<a class="header" href="#o--a-files" id="o--a-files"><h2><code>.o</code> / <code>.a</code> files</h2></a>
<p>The downside of using the <code>cc</code> crate is that it requires some assembler program
on the build machine. For example when targeting ARM Cortex-M the <code>cc</code> crate
uses <code>arm-none-eabi-gcc</code> as the assembler.</p>
<p>Instead of assembling the file on the build machine we can ship a pre-assembled
file with the <code>rt</code> crate. That way no assembler program is required on the build
machine. However, you would still need an assembler on the machine that packages
and publishes the crate.</p>
<p>There's not much difference between an assembly (<code>.s</code>) file and its <em>compiled</em>
version: the object (<code>.o</code>) file. The assembler doesn't do any optimization; it
simply chooses the right object file format for the target architecture.</p>
<p>Cargo provides support for bundling archives (<code>.a</code>) with crates. We can package
object files into an archive using the <code>ar</code> command and then bundle the archive
with the crate. In fact, this what the <code>cc</code> crate does; you can see the commands
it invoked by searching for a file named <code>output</code> in the <code>target</code> directory.</p>
<pre><code class="language-console">$ grep running $(find target -name output)
</code></pre>
<pre><code class="language-text">running: &quot;arm-none-eabi-gcc&quot; &quot;-O0&quot; &quot;-ffunction-sections&quot; &quot;-fdata-sections&quot; &quot;-fPIC&quot; &quot;-g&quot; &quot;-fno-omit-frame-pointer&quot; &quot;-mthumb&quot; &quot;-march=armv7-m&quot; &quot;-Wall&quot; &quot;-Wextra&quot; &quot;-o&quot; &quot;/tmp/app/target/thumbv7m-none-eabi/debug/build/rt-6ee84e54724f2044/out/asm.o&quot; &quot;-c&quot; &quot;asm.s&quot;
running: &quot;ar&quot; &quot;crs&quot; &quot;/tmp/app/target/thumbv7m-none-eabi/debug/build/rt-6ee84e54724f2044/out/libasm.a&quot; &quot;/home/japaric/rust-embedded/embedonomicon/ci/asm/app/target/thumbv7m-none-eabi/debug/build/rt-6ee84e54724f2044/out/asm.o&quot;
</code></pre>
<pre><code class="language-console">$ grep cargo $(find target -name output)
</code></pre>
<pre><code class="language-tetx">cargo:rustc-link-search=/tmp/app/target/thumbv7m-none-eabi/debug/build/rt-6ee84e54724f2044/out
cargo:rustc-link-lib=static=asm
cargo:rustc-link-search=native=/tmp/app/target/thumbv7m-none-eabi/debug/build/rt-6ee84e54724f2044/out
</code></pre>
<p>We'll do something similar to produce an archive.</p>
<pre><code class="language-console">$ # most of flags `cc` uses have no effect when assembling so we drop them
$ arm-none-eabi-as -march=armv7-m asm.s -o asm.o

$ ar crs librt.a asm.o

$ arm-none-eabi-objdump -Cd librt.a
</code></pre>
<pre><code class="language-text">In archive librt.a:

asm.o:     file format elf32-littlearm


Disassembly of section .text.HardFaultTrampoline:

00000000 &lt;HardFaultTrampoline&gt;:
   0:	f3ef 8008 	mrs	r0, MSP
   4:	e7fe      	b.n	0 &lt;HardFault&gt;

</code></pre>
<p>Next we modify the build script to bundle this archive with the <code>rt</code> rlib.</p>
<pre><code class="language-console">$ cat ../rt/build.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">use std::{
    env,
    error::Error,
    fs::{self, File},
    io::Write,
    path::PathBuf,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // build directory for this crate
    let out_dir = PathBuf::from(env::var_os(&quot;OUT_DIR&quot;).unwrap());

    // extend the library search path
    println!(&quot;cargo:rustc-link-search={}&quot;, out_dir.display());

    // put `link.x` in the build directory
    File::create(out_dir.join(&quot;link.x&quot;))?.write_all(include_bytes!(&quot;link.x&quot;))?;

    // link to `librt.a`
    fs::copy(&quot;librt.a&quot;, out_dir.join(&quot;librt.a&quot;))?; // &lt;- NEW!
    println!(&quot;cargo:rustc-link-lib=static=rt&quot;); // &lt;- NEW!

    // rebuild if `librt.a` changed
    println!(&quot;cargo:rerun-if-changed=librt.a&quot;); // &lt;- NEW!

    Ok(())
}

</code></pre></pre>
<p>Now we can test this new version against the simple program from before and
we'll get the same output.</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -d -no-show-raw-insn -print-imm-hex
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little


Disassembly of section .text:

HardFault:
                b	#-0x4 &lt;HardFault&gt;

main:
                trap

Reset:
                bl	#-0x6
                trap

DefaultExceptionHandler:
                b	#-0x4 &lt;DefaultExceptionHandler&gt;

UsageFault:
                &lt;unknown&gt;

HardFaultTrampoline:
                mrs	r0, msp
                b	#-0x14 &lt;HardFault&gt;

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: As before I have commented out the RAM initialization to make the
disassembly smaller.</p>
</blockquote>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -s -j .vector_table
</code></pre>
<pre><code class="language-text">
app:	file format ELF32-arm-little

Contents of section .vector_table:
 0000 00000120 45000000 4b000000 4d000000  ... E...K...M...
 0010 4b000000 4b000000 4b000000 00000000  K...K...K.......
 0020 00000000 00000000 00000000 4b000000  ............K...
 0030 00000000 00000000 4b000000 4b000000  ........K...K...

</code></pre>
<p>The downside of shipping pre-assembled archives is that, in the worst case
scenario, you'll need to ship one build artifact for each compilation target
your library supports.</p>
<a class="header" href="#logging-with-symbols" id="logging-with-symbols"><h1>Logging with symbols</h1></a>
<p>This section will show you how to utilize symbols and the ELF format to achieve
super cheap logging.</p>
<a class="header" href="#arbitrary-symbols" id="arbitrary-symbols"><h2>Arbitrary symbols</h2></a>
<p>Whenever we needed a stable symbol interface between crates we have mainly used
the <code>no_mangle</code> attribute and sometimes the <code>export_name</code> attribute. The
<code>export_name</code> attribute takes a string which becomes the name of the symbol
whereas <code>#[no_mangle]</code> is basically sugar for <code>#[export_name = &lt;item-name&gt;]</code>.</p>
<p>Turns out we are not limited to single word names; we can use arbitrary strings,
e.g. sentences, as the argument of the <code>export_name</code> attribute. As least when
the output format is ELF anything that doesn't contain a null byte is fine.</p>
<p>Let's check that out:</p>
<pre><code class="language-console">$ cargo new --lib foo

$ cat foo/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[export_name = &quot;Hello, world!&quot;]
#[used]
static A: u8 = 0;

#[export_name = &quot;こんにちは&quot;]
#[used]
static B: u8 = 0;
#}</code></pre></pre>
<pre><code class="language-console">$ ( cd foo &amp;&amp; cargo nm --lib )
foo-d26a39c34b4e80ce.3lnzqy0jbpxj4pld.rcgu.o:
0000000000000000 r Hello, world!
0000000000000000 V __rustc_debug_gdb_scripts_section__
0000000000000000 r こんにちは
</code></pre>
<p>Can you see where this is going?</p>
<a class="header" href="#encoding" id="encoding"><h2>Encoding</h2></a>
<p>Here's what we'll do: we'll create one <code>static</code> variable per log message but
instead of storing the messages <em>in</em> the variables we'll store the messages in
the variables' <em>symbol names</em>. What we'll log then will not be the contents of
the <code>static</code> variables but their addresses.</p>
<p>As long as the <code>static</code> variables are not zero sized each one will have a
different address. What we're doing here is effectively encoding each message
into a unique identifier, which happens to be the variable address. Some part of
the log system will have to decode this id back into the message.</p>
<p>Let's write some code to illustrate the idea.</p>
<p>In this example we'll need some way to do I/O so we'll use the
<a href="https://crates.io/crates/cortex-m-semihosting"><code>cortex-m-semihosting</code></a> crate for that. Semihosting is a technique for having a
target device borrow the host I/O capabilities; the host here usually refers to
the machine that's debugging the target device. In our case, QEMU supports
semihosting out of the box so there's no need for a debugger. On a real device
you'll have other ways to do I/O like a serial port; we use semihosting in this
case because it's the easiest way to do I/O on QEMU.</p>
<p>Here's the code</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use core::fmt::Write;
use cortex_m_semihosting::{debug, hio};

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    let mut hstdout = hio::hstdout().unwrap();

    #[export_name = &quot;Hello, world!&quot;]
    static A: u8 = 0;

    let _ = writeln!(hstdout, &quot;{:#x}&quot;, &amp;A as *const u8 as usize);

    #[export_name = &quot;Goodbye&quot;]
    static B: u8 = 0;

    let _ = writeln!(hstdout, &quot;{:#x}&quot;, &amp;B as *const u8 as usize);

    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

</code></pre></pre>
<p>We also make use of the <code>debug::exit</code> API to have the program terminate the QEMU
process. This is a convenience so we don't have to manually terminate the QEMU
process.</p>
<p>And here's the <code>dependencies</code> section of the Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
cortex-m-semihosting = &quot;0.3.1&quot;
rt = { path = &quot;../rt&quot; }
</code></pre>
<p>Now we can build the program</p>
<pre><code class="language-console">$ cargo build
</code></pre>
<p>To run it we'll have to add the <code>--semihosting-config</code> flag to our QEMU
invocation:</p>
<pre><code class="language-console">$ qemu-system-arm \
      -cpu cortex-m3 \
      -machine lm3s6965evb \
      -nographic \
      -semihosting-config enable=on,target=native \
      -kernel target/thumbv7m-none-eabi/debug/app
</code></pre>
<pre><code class="language-text">0x1fe0
0x1fe1

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: These addresses may not be the ones you get locally because
addresses of <code>static</code> variable are not guaranteed to remain the same when the
toolchain is changed (e.g. optimizations may have improved).</p>
</blockquote>
<p>Now we have two addresses printed to the console.</p>
<a class="header" href="#decoding" id="decoding"><h2>Decoding</h2></a>
<p>How do we convert these addresses into strings? The answer is in the symbol
table of the ELF file.</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -t | grep '\.rodata\s*0*1\b'
</code></pre>
<pre><code class="language-text">00001fe1 g       .rodata		 00000001 Goodbye
00001fe0 g       .rodata		 00000001 Hello, world!

$ # first column is the symbol address; last column is the symbol name
</code></pre>
<p><code>objdump -t</code> prints the symbol table. This table contains <em>all</em> the symbols but
we are only looking for the ones in the <code>.rodata</code> section and whose size is one
byte (our variables have type <code>u8</code>).</p>
<p>It's important to note that the address of the symbols will likely change when
optimizing the program. Let's check that.</p>
<blockquote>
<p><strong>PROTIP</strong> You can set <code>target.thumbv7m-none-eabi.runner</code> to the long QEMU
command from before (<code>qemu-system-arm -cpu (..) -kernel</code>) in the Cargo
configuration file (<code>.cargo/conifg</code>) to have <code>cargo run</code> use that <em>runner</em> to
execute the output binary.</p>
</blockquote>
<pre><code class="language-console">$ head -n2 .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
runner = &quot;qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel&quot;
</code></pre>
<pre><code class="language-console">$ cargo run --release
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel target/thumbv7m-none-eabi/release/app`
</code></pre>
<pre><code class="language-text">0xb9c
0xb9d

</code></pre>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -t | grep '\.rodata\s*0*1\b'
</code></pre>
<pre><code class="language-text">00000b9d g     O .rodata	00000001 Goodbye
00000b9c g     O .rodata	00000001 Hello, world!

</code></pre>
<p>So make sure to always look for the strings in the ELF file you executed.</p>
<p>Of course, the process of looking up the strings in the ELF file can be automated
using a tool that parses the symbol table (<code>.symtab</code> section) contained in the
ELF file. Implementing such tool is out of scope for this book and it's left as
an exercise for the reader.</p>
<a class="header" href="#making-it-zero-cost" id="making-it-zero-cost"><h2>Making it zero cost</h2></a>
<p>Can we do better? Yes, we can!</p>
<p>The current implementation places the <code>static</code> variables in <code>.rodata</code>, which
means they occupy size in Flash even though we never use their contents. Using a
little bit of linker script magic we can make them occupy <em>zero</em> space in Flash.</p>
<pre><code class="language-console">$ cat log.x
</code></pre>
<pre><code class="language-text">SECTIONS
{
  .log 0 (INFO) : {
    *(.log);
  }
}

</code></pre>
<p>We'll place the <code>static</code> variables in this new output <code>.log</code> section. This
linker script will collect all the symbols in the <code>.log</code> sections of input
object files and put them in an output <code>.log</code> section. We have seen this pattern
in the <a href="memory-layout.html">Memory layout</a> chapter.</p>
<p>The new bit here is the <code>(INFO)</code> part; this tells the linker that this section
is a non-allocatable section. Non-allocatable sections are kept in the ELF
binary as metadata but they are not loaded onto the target device.</p>
<p>We also specified the start address of this output section: the <code>0</code> in <code>.log 0 (INFO)</code>.</p>
<p>The other improvement we can do is switch from formatted I/O (<code>fmt::Write</code>) to
binary I/O, that is send the addresses to the host as bytes rather than as
strings.</p>
<p>Binary serialization can be hard but we'll keep things super simple by
serializing each address as a single byte. With this approach we don't have to
worry about endianness or framing. The downside of this format is that a single
byte can only represent up to 256 different addresses.</p>
<p>Let's make those changes:</p>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_semihosting::{debug, hio};

use rt::entry;

entry!(main);

fn main() -&gt; ! {
    let mut hstdout = hio::hstdout().unwrap();

    #[export_name = &quot;Hello, world!&quot;]
    #[link_section = &quot;.log&quot;] // &lt;- NEW!
    static A: u8 = 0;

    let address = &amp;A as *const u8 as usize as u8;
    hstdout.write_all(&amp;[address]).unwrap(); // &lt;- CHANGED!

    #[export_name = &quot;Goodbye&quot;]
    #[link_section = &quot;.log&quot;] // &lt;- NEW!
    static B: u8 = 0;

    let address = &amp;B as *const u8 as usize as u8;
    hstdout.write_all(&amp;[address]).unwrap(); // &lt;- CHANGED!

    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

</code></pre></pre>
<p>Before you run this you'll have to append <code>-Tlog.x</code> to the arguments passed to
the linker. That can be done in the Cargo configuration file.</p>
<pre><code class="language-console">$ cat .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
runner = &quot;qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel&quot;
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;,
  &quot;-C&quot;, &quot;link-arg=-Tlog.x&quot;, # &lt;- NEW!
]

[build]
target = &quot;thumbv7m-none-eabi&quot;
</code></pre>
<p>Now you can run it! Since the output now has a binary format we'll pipe it
through the <code>xxd</code> command to reformat it as a hexadecimal string.</p>
<pre><code class="language-console">$ cargo run | xxd -p
</code></pre>
<pre><code class="language-text">0001

</code></pre>
<p>The addresses are <code>0x00</code> and <code>0x01</code>. Let's now look at the symbol table.</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -t | grep '\.log'
</code></pre>
<pre><code class="language-text">00000001 g     O .log	00000001 Goodbye
00000000 g     O .log	00000001 Hello, world!

</code></pre>
<p>There are our strings. You'll notice that their addresses now start at zero;
this is because we set a start address for the output <code>.log</code> section.</p>
<p>Each variable is 1 byte in size because we are using <code>u8</code> as their type. If we
used something like <code>u16</code> then all address would be even and we would not be
able to efficiently use all the address space (<code>0...255</code>).</p>
<a class="header" href="#packaging-it-up" id="packaging-it-up"><h2>Packaging it up</h2></a>
<p>You've noticed that the steps to log a string are always the same so we can
refactor them into a macro that lives in its own crate. Also, we can make the
logging library more reusable by abstracting the I/O part behind a trait.</p>
<pre><code class="language-console">$ cargo new --lib log

$ cat log/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_std]

#fn main() {
pub trait Log {
    type Error;

    fn log(&amp;mut self, address: u8) -&gt; Result&lt;(), Self::Error&gt;;
}

#[macro_export]
macro_rules! log {
    ($logger:expr, $string:expr) =&gt; {{
        #[export_name = $string]
        #[link_section = &quot;.log&quot;]
        static SYMBOL: u8 = 0;

        $crate::Log::log(&amp;mut $logger, &amp;SYMBOL as *const u8 as usize as u8)
    }};
}

#}</code></pre></pre>
<p>Given that this library depends on the <code>.log</code> section it should be its
responsibility to provide the <code>log.x</code> linker script so let's make that happen.</p>
<pre><code class="language-console">$ mv log.x ../log/
</code></pre>
<pre><code class="language-console">$ cat ../log/build.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">use std::{env, error::Error, fs::File, io::Write, path::PathBuf};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Put the linker script somewhere the linker can find it
    let out = PathBuf::from(env::var(&quot;OUT_DIR&quot;)?);

    File::create(out.join(&quot;log.x&quot;))?.write_all(include_bytes!(&quot;log.x&quot;))?;

    println!(&quot;cargo:rustc-link-search={}&quot;, out.display());

    Ok(())
}

</code></pre></pre>
<p>Now we can refactor our application to use the <code>log!</code> macro:</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_semihosting::{
    debug,
    hio::{self, HStdout},
};

use log::{log, Log};
use rt::entry;

struct Logger {
    hstdout: HStdout,
}

impl Log for Logger {
    type Error = ();

    fn log(&amp;mut self, address: u8) -&gt; Result&lt;(), ()&gt; {
        self.hstdout.write_all(&amp;[address])
    }
}

entry!(main);

fn main() -&gt; ! {
    let hstdout = hio::hstdout().unwrap();
    let mut logger = Logger { hstdout };

    let _ = log!(logger, &quot;Hello, world!&quot;);

    let _ = log!(logger, &quot;Goodbye&quot;);

    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

</code></pre></pre>
<p>Don't forget to update the <code>Cargo.toml</code> file to depend on the new <code>log</code> crate.</p>
<pre><code class="language-console">$ tail -n4 Cargo.toml
</code></pre>
<pre><code class="language-toml">[dependencies]
cortex-m-semihosting = &quot;0.3.1&quot;
log = { path = &quot;../log&quot; }
rt = { path = &quot;../rt&quot; }
</code></pre>
<pre><code class="language-console">$ cargo run | xxd -p
</code></pre>
<pre><code class="language-text">0001

</code></pre>
<pre><code class="language-console">$ cargo objdump --bin app -- -t | grep '\.log'
</code></pre>
<pre><code class="language-text">00000001 g     O .log	00000001 Goodbye
00000000 g     O .log	00000001 Hello, world!

</code></pre>
<p>Same output as before!</p>
<a class="header" href="#bonus-multiple-log-levels" id="bonus-multiple-log-levels"><h2>Bonus: Multiple log levels</h2></a>
<p>Many logging frameworks provide ways to log messages at different <em>log levels</em>.
These log levels convey the severity of the message: &quot;this is an error&quot;, &quot;this
is just a warning&quot;, etc. These log levels can be used to filter out unimportant
messages when searching for e.g. error messages.</p>
<p>We can extend our logging library to support log levels without increasing its
footprint. Here's how we'll do that:</p>
<p>We have a flat address space for the messages: from <code>0</code> to <code>255</code> (inclusive). To
keep things simple let's say we only want to differentiate between error
messages and warning messages. We can place all the error messages at the
beginning of the address space, and all the warning messages <em>after</em> the error
messages. If the decoder knows the address of the first warning message then it
can classify the messages. This idea can be extended to support more than two
log levels.</p>
<p>Let's test the idea by replacing the <code>log</code> macro with two new macros: <code>error!</code>
and <code>warn!</code>.</p>
<pre><code class="language-console">$ cat ../log/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_std]

#fn main() {
pub trait Log {
    type Error;

    fn log(&amp;mut self, address: u8) -&gt; Result&lt;(), Self::Error&gt;;
}

/// Logs messages at the ERROR log level
#[macro_export]
macro_rules! error {
    ($logger:expr, $string:expr) =&gt; {{
        #[export_name = $string]
        #[link_section = &quot;.log.error&quot;] // &lt;- CHANGED!
        static SYMBOL: u8 = 0;

        $crate::Log::log(&amp;mut $logger, &amp;SYMBOL as *const u8 as usize as u8)
    }};
}

/// Logs messages at the WARNING log level
#[macro_export]
macro_rules! warn {
    ($logger:expr, $string:expr) =&gt; {{
        #[export_name = $string]
        #[link_section = &quot;.log.warning&quot;] // &lt;- CHANGED!
        static SYMBOL: u8 = 0;

        $crate::Log::log(&amp;mut $logger, &amp;SYMBOL as *const u8 as usize as u8)
    }};
}

#}</code></pre></pre>
<p>We distinguish errors from warnings by placing the messages in different link
sections.</p>
<p>The next thing we have to do is update the linker script to place error messages
before the warning messages.</p>
<pre><code class="language-console">$ cat ../log/log.x
</code></pre>
<pre><code class="language-text">SECTIONS
{
  .log 0 (INFO) : {
    *(.log.error);
    __log_warning_start__ = .;
    *(.log.warning);
  }
}

</code></pre>
<p>We also give a name, <code>__log_warning_start__</code>, to the boundary between the errors
and the warnings. The address of this symbol will be the address of the first
warning message.</p>
<p>We can now update the application to make use of these new macros.</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m_semihosting::{
    debug,
    hio::{self, HStdout},
};

use log::{error, warn, Log};
use rt::entry;

entry!(main);

fn main() -&gt; ! {
    let hstdout = hio::hstdout().unwrap();
    let mut logger = Logger { hstdout };

    let _ = warn!(logger, &quot;Hello, world!&quot;); // &lt;- CHANGED!

    let _ = error!(logger, &quot;Goodbye&quot;); // &lt;- CHANGED!

    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

struct Logger {
    hstdout: HStdout,
}

impl Log for Logger {
    type Error = ();

    fn log(&amp;mut self, address: u8) -&gt; Result&lt;(), ()&gt; {
        self.hstdout.write_all(&amp;[address])
    }
}

</code></pre></pre>
<p>The output won't change much:</p>
<pre><code class="language-console">$ cargo run | xxd -p
</code></pre>
<pre><code class="language-text">0100

</code></pre>
<p>We still get two bytes in the output but the error is given the address 0 and
the warning is given the address 1 even though the warning was logged first.</p>
<p>Now look at the symbol table.</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -t | grep '\.log'
</code></pre>
<pre><code class="language-text">00000000 g     O .log	00000001 Goodbye
00000001 g     O .log	00000001 Hello, world!
00000001         .log	00000000 __log_warning_start__

</code></pre>
<p>There's now an extra symbol, <code>__log_warning_start__</code>, in the <code>.log</code> section.
The address of this symbol is the address of the first warning message.
Symbols with addresses lower than this value are errors, and the rest of symbols
are warnings.</p>
<p>With an appropriate decoder you could get the following human readable output
from all this information:</p>
<pre><code class="language-text">WARNING Hello, world!
ERROR Goodbye
</code></pre>
<hr />
<p>If you liked this section check out the <a href="https://crates.io/crates/stlog"><code>stlog</code></a> logging framework which is a
complete implementation of this idea.</p>
<a class="header" href="#global-singletons" id="global-singletons"><h1>Global singletons</h1></a>
<p>In this section we'll cover how to implement a global, shared singleton. The
embedded Rust book covered local, owned singletons which are pretty much unique
to Rust. Global singletons are essentially the singleton pattern you see in C
and C++; they are not specific to embedded development but since they involve
symbols they seemed a good fit for the embedonomicon.</p>
<blockquote>
<p><strong>TODO</strong>(resources team) link &quot;the embedded Rust book&quot; to the singletons
section when it's up</p>
</blockquote>
<p>To illustrate this section we'll extend the logger we developed in the last
section to support global logging. The result will be very similar to the
<code>#[global_allocator]</code> feature covered in the embedded Rust book.</p>
<blockquote>
<p><strong>TODO</strong>(resources team) link <code>#[global_allocator]</code> to the collections chapter
of the book when it's in a more stable location.</p>
</blockquote>
<p>Here's the summary of what we want to:</p>
<p>In the last section we created a <code>log!</code> macro to log messages through a specific
logger, a value that implements the <code>Log</code> trait. The syntax of the <code>log!</code> macro
is <code>log!(logger, &quot;String&quot;)</code>. We want to extend the macro such that
<code>log!(&quot;String&quot;)</code> also works. Using the <code>logger</code>-less version should log the
message through a global logger; this is how <code>std::println!</code> works. We'll also
need a mechanism to declare what the global logger is; this is the part that's
similar to <code>#[global_allocator]</code>.</p>
<p>It could be that the global logger is declared in the top crate and it could
also be that the type of the global logger is defined in the top crate. In this
scenario the dependencies can <em>not</em> know the exact type of the global logger. To
support this scenario we'll need some indirection.</p>
<p>Instead of hardcoding the type of the global logger in the <code>log</code> crate we'll
declare only the <em>interface</em> of the global logger in that crate. That is we'll
add a new trait, <code>GlobalLog</code>, to the <code>log</code> crate. The <code>log!</code> macro will also
have to make use of that trait.</p>
<pre><code class="language-console">$ cat ../log/src/lib.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_std]

#fn main() {
// NEW!
pub trait GlobalLog: Sync {
    fn log(&amp;self, address: u8);
}

pub trait Log {
    type Error;

    fn log(&amp;mut self, address: u8) -&gt; Result&lt;(), Self::Error&gt;;
}

#[macro_export]
macro_rules! log {
    // NEW!
    ($string:expr) =&gt; {
        unsafe {
            extern &quot;Rust&quot; {
                static LOGGER: &amp;'static dyn $crate::GlobalLog;
            }

            #[export_name = $string]
            #[link_section = &quot;.log&quot;]
            static SYMBOL: u8 = 0;

            $crate::GlobalLog::log(LOGGER, &amp;SYMBOL as *const u8 as usize as u8)
        }
    };

    ($logger:expr, $string:expr) =&gt; {{
        #[export_name = $string]
        #[link_section = &quot;.log&quot;]
        static SYMBOL: u8 = 0;

        $crate::Log::log(&amp;mut $logger, &amp;SYMBOL as *const u8 as usize as u8)
    }};
}

// NEW!
#[macro_export]
macro_rules! global_logger {
    ($logger:expr) =&gt; {
        #[no_mangle]
        pub static LOGGER: &amp;dyn $crate::GlobalLog = &amp;$logger;
    };
}

#}</code></pre></pre>
<p>There's quite a bit to unpack here.</p>
<p>Let's start with the trait.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait GlobalLog: Sync {
    fn log(&amp;self, address: u8);
}
#}</code></pre></pre>
<p>Both <code>GlobalLog</code> and <code>Log</code> have a <code>log</code> method. The difference is that
<code>GlobalLog.log</code> takes a shared reference to the receiver (<code>&amp;self</code>). This is
necessary because the global logger will be a <code>static</code> variable. More on that
later.</p>
<p>The other difference is that <code>GlobalLog.log</code> doesn't return a <code>Result</code>. This
means that it can <em>not</em> report errors to the caller. This is not a strict
requirement for traits used to implement global singletons. Error handling in
global singletons is fine but then all users of the global version of the <code>log!</code>
macro have to agree on the error type. Here we are simplifying the interface a
bit by having the <code>GlobalLog</code> implementer deal with the errors.</p>
<p>Yet another difference is that <code>GlobalLog</code> requires that the implementer is
<code>Sync</code>, that is that it can be shared between threads. This is a requirement for
values placed in <code>static</code> variables; their types must implement the <code>Sync</code>
trait.</p>
<p>At this point it may not be entirely clear why the interface has to look this
way. The other parts of the crate will make this clearer so keep reading.</p>
<p>Next up is the <code>log!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    ($string:expr) =&gt; {
        unsafe {
            extern &quot;Rust&quot; {
                static LOGGER: &amp;'static dyn $crate::GlobalLog;
            }

            #[export_name = $string]
            #[link_section = &quot;.log&quot;]
            static SYMBOL: u8 = 0;

            $crate::GlobalLog::log(LOGGER, &amp;SYMBOL as *const u8 as usize as u8)
        }
    };
#}</code></pre></pre>
<p>When called without a specific <code>$logger</code> the macros uses an <code>extern</code> <code>static</code>
variable called <code>LOGGER</code> to log the message. This variable <em>is</em> the global
logger that's defined somewhere else; that's why we use the <code>extern</code> block. We
saw this pattern in the <a href="main.html">main interface</a> chapter.</p>
<p>We need to declare a type for <code>LOGGER</code> or the code won't type check. We don't
know the concrete type of <code>LOGGER</code> at this point but we know, or rather require,
that it implements the <code>GlobalLog</code> trait so we can use a trait object here.</p>
<p>The rest of the macro expansion looks very similar to the expansion of the local
version of the <code>log!</code> macro so I won't explain it here as it's explained in the
<a href="logging.html">previous</a> chapter.</p>
<p>Now that we know that <code>LOGGER</code> has to be a trait object it's clearer why we
omitted the associated <code>Error</code> type in <code>GlobalLog</code>. If we had not omitted then
we would have need to pick a type for <code>Error</code> in the type signature of <code>LOGGER</code>.
This is what I earlier meant by &quot;all users of <code>log!</code> would need to agree on the
error type&quot;.</p>
<p>Now the final piece: the <code>global_logger!</code> macro. It could have been a proc macro
attribute but it's easier to write a <code>macro_rules!</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! global_logger {
    ($logger:expr) =&gt; {
        #[no_mangle]
        pub static LOGGER: &amp;dyn $crate::GlobalLog = &amp;$logger;
    };
}
#}</code></pre></pre>
<p>This macro creates the <code>LOGGER</code> variable that <code>log!</code> uses. Because we need a
stable ABI interface we use the <code>no_mangle</code> attribute. This way the symbol name
of <code>LOGGER</code> will be &quot;LOGGER&quot; which is what the <code>log!</code> macro expects.</p>
<p>The other important bit is that the type of this static variable must exactly
match the type used in the expansion of the <code>log!</code> macro. If they don't match
Bad Stuff will happen due to ABI mismatch.</p>
<p>Let's write an example that uses this new global logger functionality.</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::interrupt;
use cortex_m_semihosting::{
    debug,
    hio::{self, HStdout},
};

use log::{global_logger, log, GlobalLog};
use rt::entry;

struct Logger;

global_logger!(Logger);

entry!(main);

fn main() -&gt; ! {
    log!(&quot;Hello, world!&quot;);

    log!(&quot;Goodbye&quot;);

    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

impl GlobalLog for Logger {
    fn log(&amp;self, address: u8) {
        // we use a critical section (`interrupt::free`) to make the access to the
        // `static mut` variable interrupt safe which is required for memory safety
        interrupt::free(|_| unsafe {
            static mut HSTDOUT: Option&lt;HStdout&gt; = None;

            // lazy initialization
            if HSTDOUT.is_none() {
                HSTDOUT = Some(hio::hstdout()?);
            }

            let hstdout = HSTDOUT.as_mut().unwrap();

            hstdout.write_all(&amp;[address])
        }).ok(); // `.ok()` = ignore errors
    }
}

</code></pre></pre>
<blockquote>
<p><strong>TODO</strong>(resources team) use <code>cortex_m::Mutex</code> instead of a <code>static mut</code>
variable when <code>const fn</code> is stabilized.</p>
</blockquote>
<p>We had to add <code>cortex-m</code> to the dependencies.</p>
<pre><code class="language-console">$ tail -n5 Cargo.toml
</code></pre>
<pre><code class="language-text">[dependencies]
cortex-m = &quot;0.5.7&quot;
cortex-m-semihosting = &quot;0.3.1&quot;
log = { path = &quot;../log&quot; }
rt = { path = &quot;../rt&quot; }
</code></pre>
<p>This is a port of one of the examples written in the <a href="logging.html">previous</a> section. The
output is the same as what we got back there.</p>
<pre><code class="language-console">$ cargo run | xxd -p
</code></pre>
<pre><code class="language-text">0001

</code></pre>
<pre><code class="language-console">$ cargo objdump --bin app -- -t | grep '\.log'
</code></pre>
<pre><code class="language-text">00000001 g     O .log	00000001 Goodbye
00000000 g     O .log	00000001 Hello, world!

</code></pre>
<hr />
<p>Some readers may be concerned about this implementation of global singletons not
being zero cost because it uses trait objects which involve dynamic dispatch,
that is method calls are performed through a vtable lookup.</p>
<p>However, it appears that LLVM is smart enough to eliminate the dynamic dispatch
when compiling with optimizations / LTO. This can be confirmed by searching for
<code>LOGGER</code> in the symbol table.</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -t | grep LOGGER
</code></pre>
<pre><code class="language-text">
</code></pre>
<p>If the <code>static</code> is missing that means that there is no vtable and that LLVM was
capable of transforming all the <code>LOGGER.log</code> calls into <code>Logger.log</code> calls.</p>
<a class="header" href="#direct-memory-access-dma" id="direct-memory-access-dma"><h1>Direct Memory Access (DMA)</h1></a>
<p>This section covers the core requirements for building a memory safe API around
DMA transfers.</p>
<p>The DMA peripheral is used to perform memory transfers in parallel to the work
of the processor (the execution of the main program). A DMA transfer is more or
less equivalent to spawning a thread (see <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a>) to do a <code>memcpy</code>.
We'll use the fork-join model to illustrate the requirements of a memory safe
API.</p>
<p>Consider the following DMA primitives:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A singleton that represents a single DMA channel (channel 1 in this case)
///
/// This singleton has exclusive access to the registers of the DMA channel 1
pub struct Dma1Channel1 {
    // ..
}

impl Dma1Channel1 {
    /// Data will be written to this `address`
    ///
    /// `inc` indicates whether the address will be incremented after every byte transfer
    ///
    /// NOTE this performs a volatile write
    pub fn set_destination_address(&amp;mut self, address: usize, inc: bool) {
        // ..
    }

    /// Data will be read from this `address`
    ///
    /// `inc` indicates whether the address will be incremented after every byte transfer
    ///
    /// NOTE this performs a volatile write
    pub fn set_source_address(&amp;mut self, address: usize, inc: bool) {
        // ..
    }

    /// Number of bytes to transfer
    ///
    /// NOTE this performs a volatile write
    pub fn set_transfer_length(&amp;mut self, len: usize) {
        // ..
    }

    /// Starts the DMA transfer
    ///
    /// NOTE this performs a volatile write
    pub fn start(&amp;mut self) {
        // ..
    }

    /// Stops the DMA transfer
    ///
    /// NOTE this performs a volatile write
    pub fn stop(&amp;mut self) {
        // ..
    }

    /// Returns `true` if there's a transfer in progress
    ///
    /// NOTE this performs a volatile read
    pub fn in_progress() -&gt; bool {
        // ..
    }
}
#}</code></pre></pre>
<p>Assume that the <code>Dma1Channel1</code> is statically configured to work with serial port
(AKA UART or USART) #1, <code>Serial1</code>, in one-shot mode (i.e. not circular mode).
<code>Serial1</code> provides the following <em>blocking</em> API:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A singleton that represents serial port #1
pub struct Serial1 {
    // ..
}

impl Serial1 {
    /// Reads out a single byte
    ///
    /// NOTE: blocks if no byte is available to be read
    pub fn read(&amp;mut self) -&gt; Result&lt;u8, Error&gt; {
        // ..
    }

    /// Sends out a single byte
    ///
    /// NOTE: blocks if the output FIFO buffer is full
    pub fn write(&amp;mut self, byte: u8) -&gt; Result&lt;(), Error&gt; {
        // ..
    }
}
#}</code></pre></pre>
<p>Let's say we want to extend <code>Serial1</code> API to (a) asynchronously send out a
buffer and (b) asynchronously fill a buffer.</p>
<p>We'll start with a memory unsafe API and we'll iterate on it until it's
completely memory safe. On each step we'll show you how the API can be broken to
make you aware of the issues that need to be addressed when dealing with
asynchronous memory operations.</p>
<a class="header" href="#a-first-stab" id="a-first-stab"><h2>A first stab</h2></a>
<p>For starters, let's try to use the <a href="https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all"><code>Write::write_all</code></a> API as a reference. To
keep things simple let's ignore all error handling.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A singleton that represents serial port #1
pub struct Serial1 {
    // NOTE: we extend this struct by adding the DMA channel singleton
    dma: Dma1Channel1,
    // ..
}

impl Serial1 {
    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;'a&gt;(mut self, buffer: &amp;'a [u8]) -&gt; Transfer&lt;&amp;'a [u8]&gt; {
        self.dma.set_destination_address(USART1_TX, false);
        self.dma.set_source_address(buffer.as_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        self.dma.start();

        Transfer { buffer }
    }
}

/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    buffer: B,
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Returns `true` if the DMA transfer has finished
    pub fn is_done(&amp;self) -&gt; bool {
        !Dma1Channel1::in_progress()
    }

    /// Blocks until the transfer is done and returns the buffer
    pub fn wait(self) -&gt; B {
        // Busy wait until the transfer is done
        while !self.is_done() {}

        self.buffer
    }
}
#}</code></pre></pre>
<blockquote>
<p><strong>NOTE:</strong> <code>Transfer</code> could expose a futures or generator based API instead of
the API shown above. That's an API design question that has little bearing on
the memory safety of the overall API so we won't delve into it in this text.</p>
</blockquote>
<p>We can also implement an asynchronous version of <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact"><code>Read::read_exact</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;'a&gt;(&amp;mut self, buffer: &amp;'a mut [u8]) -&gt; Transfer&lt;&amp;'a mut [u8]&gt; {
        self.dma.set_source_address(USART1_RX, false);
        self.dma
            .set_destination_address(buffer.as_mut_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        self.dma.start();

        Transfer { buffer }
    }
}
#}</code></pre></pre>
<p>Here's how to use the <code>write_all</code> API:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn write(serial: Serial1) {
    // fire and forget
    serial.write_all(b&quot;Hello, world!\n&quot;);

    // do other stuff
}
#}</code></pre></pre>
<p>And here's an example of using the <code>read_exact</code> API:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read(mut serial: Serial1) {
    let mut buf = [0; 16];
    let t = serial.read_exact(&amp;mut buf);

    // do other stuff

    t.wait();

    match buf.split(|b| *b == b'\n').next() {
        Some(b&quot;some-command&quot;) =&gt; { /* do something */ }
        _ =&gt; { /* do something else */ }
    }
}
#}</code></pre></pre>
<a class="header" href="#memforget" id="memforget"><h2><code>mem::forget</code></h2></a>
<p><a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>mem::forget</code></a> is a safe API. If our API is truly safe then we should be able
to use both together without running into undefined behavior. However, that's
not the case; consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn unsound(mut serial: Serial1) {
    start(&amp;mut serial);
    bar();
}

#[inline(never)]
fn start(serial: &amp;mut Serial1) {
    let mut buf = [0; 16];

    // start a DMA transfer and forget the returned `Transfer` value
    mem::forget(serial.read_exact(&amp;mut buf));
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
#}</code></pre></pre>
<p>Here we start a DMA transfer, in <code>start</code>, to fill an array allocated on the
stack and then <code>mem::forget</code> the returned <code>Transfer</code> value. Then we proceed to
return from <code>start</code> and execute the function <code>bar</code>.</p>
<p>This series of operations results in undefined behavior. The DMA transfer writes
to stack memory but that memory is released when <code>start</code> returns and then reused
by <code>bar</code> to allocate variables like <code>x</code> and <code>y</code>. At runtime this could result in
variables <code>x</code> and <code>y</code> changing their value at random times. The DMA transfer
could also overwrite the state (e.g. link register) pushed onto the stack by the
prologue of function <code>bar</code>.</p>
<p>Note that if we had not use <code>mem::forget</code>, but <code>mem::drop</code>, it would have been
possible to make <code>Transfer</code>'s destructor stop the DMA transfer and then the
program would have been safe. But one can <em>not</em> rely on destructors running to
enforce memory safety because <code>mem::forget</code> and memory leaks (see RC cycles) are
safe in Rust.</p>
<p>We can fix this particular problem by changing the lifetime of the buffer from
<code>'a</code> to <code>'static</code> in both APIs.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact(&amp;mut self, buffer: &amp;'static mut [u8]) -&gt; Transfer&lt;&amp;'static mut [u8]&gt; {
        // .. same as before ..
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all(mut self, buffer: &amp;'static [u8]) -&gt; Transfer&lt;&amp;'static [u8]&gt; {
        // .. same as before ..
    }
}
#}</code></pre></pre>
<p>If we try to replicate the previous problem we note that <code>mem::forget</code> no longer
causes problems.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[allow(dead_code)]
fn sound(mut serial: Serial1, buf: &amp;'static mut [u8; 16]) {
    // NOTE `buf` is moved into `foo`
    foo(&amp;mut serial, buf);
    bar();
}

#[inline(never)]
fn foo(serial: &amp;mut Serial1, buf: &amp;'static mut [u8]) {
    // start a DMA transfer and forget the returned `Transfer` value
    mem::forget(serial.read_exact(buf));
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
#}</code></pre></pre>
<p>As before, the DMA transfer continues after <code>mem::forget</code>-ing the <code>Transfer</code>
value. This time that's not an issue because <code>buf</code> is statically allocated
(e.g. <code>static mut</code> variable) and not on the stack.</p>
<a class="header" href="#overlapping-use" id="overlapping-use"><h2>Overlapping use</h2></a>
<p>Our API doesn't prevent the user from using the <code>Serial</code> interface while the DMA
transfer is in progress. This could lead the transfer to fail or data to be
lost.</p>
<p>There are several ways to prevent overlapping use. One way is to have <code>Transfer</code>
take ownership of <code>Serial1</code> and return it back when <code>wait</code> is called.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    buffer: B,
    // NOTE: added
    serial: Serial1,
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Blocks until the transfer is done and returns the buffer
    // NOTE: the return value has changed
    pub fn wait(self) -&gt; (B, Serial1) {
        // Busy wait until the transfer is done
        while !self.is_done() {}

        (self.buffer, self.serial)
    }

    // ..
}

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    // NOTE we now take `self` by value
    pub fn read_exact(mut self, buffer: &amp;'static mut [u8]) -&gt; Transfer&lt;&amp;'static mut [u8]&gt; {
        // .. same as before ..

        Transfer {
            buffer,
            // NOTE: added
            serial: self,
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    // NOTE we now take `self` by value
    pub fn write_all(mut self, buffer: &amp;'static [u8]) -&gt; Transfer&lt;&amp;'static [u8]&gt; {
        // .. same as before ..

        Transfer {
            buffer,
            // NOTE: added
            serial: self,
        }
    }
}
#}</code></pre></pre>
<p>The move semantics statically prevent access to <code>Serial1</code> while the transfer is
in progress.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read(serial: Serial1, buf: &amp;'static mut [u8; 16]) {
    let t = serial.read_exact(buf);

    // let byte = serial.read(); //~ ERROR: `serial` has been moved

    // .. do stuff ..

    let (serial, buf) = t.wait();

    // .. do more stuff ..
}
#}</code></pre></pre>
<p>There are other ways to prevent overlapping use. For example, a (<code>Cell</code>) flag
that indicates whether a DMA transfer is in progress could be added to
<code>Serial1</code>. When the flag is set <code>read</code>, <code>write</code>, <code>read_exact</code> and <code>write_all</code>
would all return an error (e.g. <code>Error::InUse</code>) at runtime. The flag would be
set when <code>write_all</code> / <code>read_exact</code> is used and cleared in <code>Transfer.wait</code>.</p>
<a class="header" href="#compiler-misoptimizations" id="compiler-misoptimizations"><h2>Compiler (mis)optimizations</h2></a>
<p>The compiler is free to re-order and merge non-volatile memory operations to
better optimize a program. With our current API, this freedom can lead to
undefined behavior. Consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn reorder(serial: Serial1, buf: &amp;'static mut [u8]) {
    // zero the buffer (for no particular reason)
    buf.iter_mut().for_each(|byte| *byte = 0);

    let t = serial.read_exact(buf);

    // ... do other stuff ..

    let (buf, serial) = t.wait();

    buf.reverse();

    // .. do stuff with `buf` ..
}
#}</code></pre></pre>
<p>Here the compiler is free to move <code>buf.reverse()</code> before <code>t.wait()</code>, which would
result in a data race: both the processor and the DMA would end up modifying
<code>buf</code> at the same time. Similarly the compiler can move the zeroing operation to
after <code>read_exact</code>, which would also result in a data race.</p>
<p>To prevent these problematic reorderings we can use a <a href="https://doc.rust-lang.org/core/sync/atomic/fn.compiler_fence.html"><code>compiler_fence</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact(mut self, buffer: &amp;'static mut [u8]) -&gt; Transfer&lt;&amp;'static mut [u8]&gt; {
        self.dma.set_source_address(USART1_RX, false);
        self.dma
            .set_destination_address(buffer.as_mut_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        // NOTE: added
        atomic::compiler_fence(Ordering::Release);

        // NOTE: this is a volatile *write*
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all(mut self, buffer: &amp;'static [u8]) -&gt; Transfer&lt;&amp;'static [u8]&gt; {
        self.dma.set_destination_address(USART1_TX, false);
        self.dma.set_source_address(buffer.as_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        // NOTE: added
        atomic::compiler_fence(Ordering::Release);

        // NOTE: this is a volatile *write*
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Blocks until the transfer is done and returns the buffer
    pub fn wait(self) -&gt; (B, Serial1) {
        // NOTE: this is a volatile *read*
        while !self.is_done() {}

        // NOTE: added
        atomic::compiler_fence(Ordering::Acquire);

        (self.buffer, self.serial)
    }

    // ..
}
#}</code></pre></pre>
<p>We use <code>Ordering::Release</code> in <code>read_exact</code> and <code>write_all</code> to prevent all
preceding memory operations from being moved <em>after</em> <code>self.dma.start()</code>, which
performs a volatile write.</p>
<p>Likewise, we use <code>Ordering::Acquire</code> in <code>Transfer.wait</code> to prevent all
subsequent memory operations from being moved <em>before</em> <code>self.is_done()</code>, which
performs a volatile read.</p>
<p>To better visualize the effect of the fences here's a slightly tweaked version
of the example from the previous section. We have added the fences and their
orderings in the comments.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn reorder(serial: Serial1, buf: &amp;'static mut [u8], x: &amp;mut u32) {
    // zero the buffer (for no particular reason)
    buf.iter_mut().for_each(|byte| *byte = 0);

    *x += 1;

    let t = serial.read_exact(buf); // compiler_fence(Ordering::Release) ▲

    // NOTE: the processor can't access `buf` between the fences
    // ... do other stuff ..
    *x += 2;

    let (buf, serial) = t.wait(); // compiler_fence(Ordering::Acquire) ▼

    *x += 3;

    buf.reverse();

    // .. do stuff with `buf` ..
}
#}</code></pre></pre>
<p>The zeroing operation can <em>not</em> be moved <em>after</em> <code>read_exact</code> due to the
<code>Release</code> fence. Similarly, the <code>reverse</code> operation can <em>not</em> be moved <em>before</em>
<code>wait</code> due to the <code>Acquire</code> fence. The memory operations <em>between</em> both fences
<em>can</em> be freely reordered across the fences but none of those operations
involves <code>buf</code> so such reorderings do <em>not</em> result in undefined behavior.</p>
<p>Note that <code>compiler_fence</code> is a bit stronger than what's required. For example,
the fences will prevent the operations on <code>x</code> from being merged even though we
know that <code>buf</code> doesn't overlap with <code>x</code> (due to Rust aliasing rules). However,
there exist no intrinsic that's more fine grained than <code>compiler_fence</code>.</p>
<a class="header" href="#dont-we-need-a-memory-barrier" id="dont-we-need-a-memory-barrier"><h3>Don't we need a memory barrier?</h3></a>
<p>That depends on the target architecture. In the case of Cortex M0 to M4F cores,
<a href="https://static.docs.arm.com/dai0321/a/DAI0321A_programming_guide_memory_barriers_for_m_profile.pdf">AN321</a> says:</p>
<blockquote>
<p>3.2 Typical usages</p>
<p>(..)</p>
<p>The use of DMB is rarely needed in Cortex-M processors because they do not
reorder memory transactions. However, it is needed if the software is to be
reused on other ARM processors, especially multi-master systems. For example:</p>
<ul>
<li>DMA controller configuration. A barrier is required between a CPU memory
access and a DMA operation.</li>
</ul>
<p>(..)</p>
<p>4.18 Multi-master systems</p>
<p>(..)</p>
<p>Omitting the DMB or DSB instruction in the examples in Figure 41 on page 47
and Figure 42 would not cause any error because the Cortex-M processors:</p>
<ul>
<li>do not re-order memory transfers</li>
<li>do not permit two write transfers to be overlapped.</li>
</ul>
</blockquote>
<p>Where Figure 41 shows a DMB (memory barrier) instruction being used before
starting a DMA transaction.</p>
<p>In the case of Cortex-M7 cores you'll need memory barriers (DMB/DSB) if you are
using the data cache (DCache), unless you manually invalidate the buffer used by
the DMA. Even with the data cache disabled, memory barriers might still be
required to avoid reordering in the store buffer.</p>
<p>If your target is a multi-core system then it's very likely that you'll need
memory barriers.</p>
<p>If you do need the memory barrier then you need to use <a href="https://doc.rust-lang.org/core/sync/atomic/fn.fence.html"><code>atomic::fence</code></a> instead
of <code>compiler_fence</code>. That should generate a DMB instruction on Cortex-M devices.</p>
<a class="header" href="#generic-buffer" id="generic-buffer"><h2>Generic buffer</h2></a>
<p>Our API is more restrictive that it needs to be. For example, the following
program won't be accepted even though it's valid.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn reuse(serial: Serial1, msg: &amp;'static mut [u8]) {
    // send a message
    let t1 = serial.write_all(msg);

    // ..

    let (msg, serial) = t1.wait(); // `msg` is now `&amp;'static [u8]`

    msg.reverse();

    // now send it in reverse
    let t2 = serial.write_all(msg);

    // ..

    let (buf, serial) = t2.wait();

    // ..
}
#}</code></pre></pre>
<p>To accept such program we can make the buffer argument generic.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// as-slice = &quot;0.1.0&quot;
use as_slice::{AsMutSlice, AsSlice};

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: B) -&gt; Transfer&lt;B&gt;
    where
        B: AsMutSlice&lt;Element = u8&gt;,
    {
        // NOTE: added
        let slice = buffer.as_mut_slice();
        let (ptr, len) = (slice.as_mut_ptr(), slice.len());

        self.dma.set_source_address(USART1_RX, false);

        // NOTE: tweaked
        self.dma.set_destination_address(ptr as usize, true);
        self.dma.set_transfer_length(len);

        atomic::compiler_fence(Ordering::Release);
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    fn write_all&lt;B&gt;(mut self, buffer: B) -&gt; Transfer&lt;B&gt;
    where
        B: AsSlice&lt;Element = u8&gt;,
    {
        // NOTE: added
        let slice = buffer.as_slice();
        let (ptr, len) = (slice.as_ptr(), slice.len());

        self.dma.set_destination_address(USART1_TX, false);

        // NOTE: tweaked
        self.dma.set_source_address(ptr as usize, true);
        self.dma.set_transfer_length(len);

        atomic::compiler_fence(Ordering::Release);
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }
}

#}</code></pre></pre>
<blockquote>
<p><strong>NOTE:</strong> <code>AsRef&lt;[u8]&gt;</code> (<code>AsMut&lt;[u8]&gt;</code>) could have been used instead of
<code>AsSlice&lt;Element = u8&gt;</code> (<code>AsMutSlice&lt;Element = u8</code>).</p>
</blockquote>
<p>Now the <code>reuse</code> program will be accepted.</p>
<a class="header" href="#immovable-buffers" id="immovable-buffers"><h2>Immovable buffers</h2></a>
<p>With this modification the API will also accept arrays by value (e.g. <code>[u8; 16]</code>). However, using arrays can result in pointer invalidation. Consider the
following program.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn invalidate(serial: Serial1) {
    let t = start(serial);

    bar();

    let (buf, serial) = t.wait();
}

#[inline(never)]
fn start(serial: Serial1) -&gt; Transfer&lt;[u8; 16]&gt; {
    // array allocated in this frame
    let buffer = [0; 16];

    serial.read_exact(buffer)
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
#}</code></pre></pre>
<p>The <code>read_exact</code> operation will use the address of the <code>buffer</code> local to the
<code>start</code> function. That local <code>buffer</code> will be freed when <code>start</code> returns and the
pointer used in <code>read_exact</code> will become invalidated. You'll end up with a
situation similar to the <a href="#dealing-with-memforget"><code>unsound</code></a> example.</p>
<p>To avoid this problem we require that the buffer used with our API retains its
memory location even when it's moved. The <a href="https://doc.rust-lang.org/nightly/std/pin/index.html"><code>Pin</code></a> newtype provides such
guarantee. We can update our API to required that all buffers are &quot;pinned&quot;
first.</p>
<blockquote>
<p><strong>NOTE:</strong> To compile all the programs below this point you'll need Rust
<code>&gt;=1.33.0</code>. As of time of writing (2019-01-04) that means using the nightly
channel.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    // NOTE: changed
    buffer: Pin&lt;B&gt;,
    serial: Serial1,
}

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: bounds changed
        B: DerefMut,
        B::Target: AsMutSlice&lt;Element = u8&gt; + Unpin,
    {
        // .. same as before ..
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;B&gt;(mut self, buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: bounds changed
        B: Deref,
        B::Target: AsSlice&lt;Element = u8&gt;,
    {
        // .. same as before ..
    }
}
#}</code></pre></pre>
<blockquote>
<p><strong>NOTE:</strong> We could have used the <a href="https://crates.io/crates/stable_deref_trait"><code>StableDeref</code></a> trait instead of the <code>Pin</code>
newtype but opted for <code>Pin</code> since it's provided in the standard library.</p>
</blockquote>
<p>With this new API we can use <code>&amp;'static mut</code> references, <code>Box</code>-ed slices, <code>Rc</code>-ed
slices, etc.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn static_mut(serial: Serial1, buf: &amp;'static mut [u8]) {
    let buf = Pin::new(buf);

    let t = serial.read_exact(buf);

    // ..

    let (buf, serial) = t.wait();

    // ..
}

fn boxed(serial: Serial1, buf: Box&lt;[u8]&gt;) {
    let buf = Pin::new(buf);

    let t = serial.read_exact(buf);

    // ..

    let (buf, serial) = t.wait();

    // ..
}
#}</code></pre></pre>
<a class="header" href="#static-bound" id="static-bound"><h2><code>'static</code> bound</h2></a>
<p>Does pinning let us safely use stack allocated arrays? The answer is <em>no</em>.
Consider the following example.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn unsound(serial: Serial1) {
    start(serial);

    bar();
}

// pin-utils = &quot;0.1.0-alpha.4&quot;
use pin_utils::pin_mut;

#[inline(never)]
fn start(serial: Serial1) {
    let buffer = [0; 16];

    // pin the `buffer` to this stack frame
    // `buffer` now has type `Pin&lt;&amp;mut [u8; 16]&gt;`
    pin_mut!(buffer);

    mem::forget(serial.read_exact(buffer));
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
#}</code></pre></pre>
<p>As seen many times before, the above program runs into undefined behavior due to
stack frame corruption.</p>
<p>The API is unsound for buffers of type <code>Pin&lt;&amp;'a mut [u8]&gt;</code> where <code>'a</code> is <em>not</em>
<code>'static</code>. To prevent the problem we have to add a <code>'static</code> bound in some
places.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: added 'static bound
        B: DerefMut + 'static,
        B::Target: AsMutSlice&lt;Element = u8&gt; + Unpin,
    {
        // .. same as before ..
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;B&gt;(mut self, buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: added 'static bound
        B: Deref + 'static,
        B::Target: AsSlice&lt;Element = u8&gt;,
    {
        // .. same as before ..
    }
}
#}</code></pre></pre>
<p>Now the problematic program will be rejected.</p>
<a class="header" href="#destructors" id="destructors"><h2>Destructors</h2></a>
<p>Now that the API accepts <code>Box</code>-es and other types that have destructors we need
to decide what to do when <code>Transfer</code> is early-dropped.</p>
<p>Normally, <code>Transfer</code> values are consumed using the <code>wait</code> method but it's also
possible to, implicitly or explicitly, <code>drop</code> the value before the transfer is
over. For example, dropping a <code>Transfer&lt;Box&lt;[u8]&gt;&gt;</code> value will cause the buffer
to be deallocated. This can result in undefined behavior if the transfer is
still in progress as the DMA would end up writing to deallocated memory.</p>
<p>In such scenario one option is to make <code>Transfer.drop</code> stop the DMA transfer.
The other option is to make <code>Transfer.drop</code> wait for the transfer to finish.
We'll pick the former option as it's cheaper.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    // NOTE: always `Some` variant
    inner: Option&lt;Inner&lt;B&gt;&gt;,
}

// NOTE: previously named `Transfer&lt;B&gt;`
struct Inner&lt;B&gt; {
    buffer: Pin&lt;B&gt;,
    serial: Serial1,
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Blocks until the transfer is done and returns the buffer
    pub fn wait(mut self) -&gt; (Pin&lt;B&gt;, Serial1) {
        while !self.is_done() {}

        atomic::compiler_fence(Ordering::Acquire);

        let inner = self
            .inner
            .take()
            .unwrap_or_else(|| unsafe { hint::unreachable_unchecked() });
        (inner.buffer, inner.serial)
    }
}

impl&lt;B&gt; Drop for Transfer&lt;B&gt; {
    fn drop(&amp;mut self) {
        if let Some(inner) = self.inner.as_mut() {
            // NOTE: this is a volatile write
            inner.serial.dma.stop();

            // we need a read here to make the Acquire fence effective
            // we do *not* need this if `dma.stop` does a RMW operation
            unsafe {
                ptr::read_volatile(&amp;0);
            }

            // we need a fence here for the same reason we need one in `Transfer.wait`
            atomic::compiler_fence(Ordering::Acquire);
        }
    }
}

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        B: DerefMut + 'static,
        B::Target: AsMutSlice&lt;Element = u8&gt; + Unpin,
    {
        // .. same as before ..

        Transfer {
            inner: Some(Inner {
                buffer,
                serial: self,
            }),
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;B&gt;(mut self, buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        B: Deref + 'static,
        B::Target: AsSlice&lt;Element = u8&gt;,
    {
        // .. same as before ..

        Transfer {
            inner: Some(Inner {
                buffer,
                serial: self,
            }),
        }
    }
}
#}</code></pre></pre>
<p>Now the DMA transfer will be stopped before the buffer is deallocated.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn reuse(serial: Serial1) {
    let buf = Pin::new(Box::new([0; 16]));

    let t = serial.read_exact(buf); // compiler_fence(Ordering::Release) ▲

    // ..

    // this stops the DMA transfer and frees memory
    mem::drop(t); // compiler_fence(Ordering::Acquire) ▼

    // this likely reuses the previous memory allocation
    let mut buf = Box::new([0; 16]);

    // .. do stuff with `buf` ..
}
#}</code></pre></pre>
<a class="header" href="#summary" id="summary"><h2>Summary</h2></a>
<p>To sum it up, we need to consider all the following points to achieve  memory
safe DMA transfers:</p>
<ul>
<li>
<p>Use immovable buffers plus indirection: <code>Pin&lt;B&gt;</code>. Alternatively, you can use
the <code>StableDeref</code> trait.</p>
</li>
<li>
<p>The ownership of the buffer must be passed to the DMA : <code>B: 'static</code>.</p>
</li>
<li>
<p>Do <em>not</em> rely on destructors running for memory safety. Consider what happens
if <code>mem::forget</code> is used with your API.</p>
</li>
<li>
<p><em>Do</em> add a custom destructor that stops the DMA transfer, or waits for it to
finish. Consider what happens if <code>mem::drop</code> is used with your API.</p>
</li>
</ul>
<hr />
<p>This text leaves out up several details required to build a production grade
DMA abstraction, like configuring the DMA channels (e.g. streams, circular vs
one-shot mode, etc.), alignment of buffers, error handling, how to make the
abstraction device-agnostic, etc. All those aspects are left as an exercise for
the reader / community (<code>:P</code>).</p>
<a class="header" href="#a-note-on-compiler-support" id="a-note-on-compiler-support"><h1>A note on compiler support</h1></a>
<p>This book makes use of a built-in <em>compiler</em> target, the <code>thumbv7m-none-eabi</code>, for which the Rust
team distributes a <code>rust-std</code> component, which is a pre-compiled collection of crates like <a href="https://doc.rust-lang.org/core/index.html"><code>core</code></a> and <a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a>.</p>
<p>If you want to attempt replicating the contents of this book for a different target architecture, you
need to take into account the different levels of support that Rust provides for (compilation)
targets.</p>
<a class="header" href="#llvm-support" id="llvm-support"><h2>LLVM support</h2></a>
<p>As of Rust 1.28, the official Rust compiler, <code>rustc</code>, uses LLVM for (machine) code generation. The
minimal level of support Rust provides for an architecture is having its LLVM backend enabled in
<code>rustc</code>. You can see all the architectures that <code>rustc</code> supports, through LLVM, by running the
following command:</p>
<pre><code class="language-console">$ # you need to have `cargo-binutils` installed to run this command
$ cargo objdump -- -version
LLVM (http://llvm.org/):
  LLVM version 7.0.0svn
  Optimized build.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake

  Registered Targets:
    aarch64    - AArch64 (little endian)
    aarch64_be - AArch64 (big endian)
    arm        - ARM
    arm64      - ARM64 (little endian)
    armeb      - ARM (big endian)
    hexagon    - Hexagon
    mips       - Mips
    mips64     - Mips64 [experimental]
    mips64el   - Mips64el [experimental]
    mipsel     - Mipsel
    msp430     - MSP430 [experimental]
    nvptx      - NVIDIA PTX 32-bit
    nvptx64    - NVIDIA PTX 64-bit
    ppc32      - PowerPC 32
    ppc64      - PowerPC 64
    ppc64le    - PowerPC 64 LE
    sparc      - Sparc
    sparcel    - Sparc LE
    sparcv9    - Sparc V9
    systemz    - SystemZ
    thumb      - Thumb
    thumbeb    - Thumb (big endian)
    wasm32     - WebAssembly 32-bit
    wasm64     - WebAssembly 64-bit
    x86        - 32-bit X86: Pentium-Pro and above
    x86-64     - 64-bit X86: EM64T and AMD64
</code></pre>
<p>If LLVM supports the architecture you are interested in, but <code>rustc</code> is built with the backend
disabled (which is the case of AVR as of Rust 1.28), then you will need to modify the Rust source
enabling it. The first two commits of PR <a href="https://github.com/rust-lang/rust/pull/52787">rust-lang/rust#52787</a> give you an idea of the required
changes.</p>
<p>On the other hand, if LLVM doesn't support the architecture, but a fork of LLVM does, you will have
to replace the original version of LLVM with the fork before building <code>rustc</code>. The Rust build system
allows this and in principle it should just require changing the <code>llvm</code> submodule to point to the fork.</p>
<p>If your target architecture is only supported by some vendor provided GCC, you have the option of
using <a href="https://github.com/thepowersgang/mrustc"><code>mrustc</code></a>, an unofficial Rust compiler, to translate your Rust program into C code and then
compile that using GCC.</p>
<a class="header" href="#built-in-target" id="built-in-target"><h2>Built-in target</h2></a>
<p>A compilation target is more than just its architecture. Each target has a <a href="https://github.com/rust-lang/rfcs/blob/master/text/0131-target-specification.md">specification</a>
associated to it that describes, among other things, its architecture, its operating system
and the default linker.</p>
<p>The Rust compiler knows about several targets. These are said to be <em>built into</em> the compiler and
can be listed by running the following command:</p>
<pre><code class="language-console">$ rustc --print target-list | column
aarch64-fuchsia                 mips64el-unknown-linux-gnuabi64
aarch64-linux-android           mipsel-unknown-linux-gnu
aarch64-unknown-cloudabi        mipsel-unknown-linux-musl
aarch64-unknown-freebsd         mipsel-unknown-linux-uclibc
aarch64-unknown-linux-gnu       msp430-none-elf
aarch64-unknown-linux-musl      powerpc-unknown-linux-gnu
aarch64-unknown-openbsd         powerpc-unknown-linux-gnuspe
arm-linux-androideabi           powerpc-unknown-netbsd
arm-unknown-linux-gnueabi       powerpc64-unknown-linux-gnu
arm-unknown-linux-gnueabihf     powerpc64le-unknown-linux-gnu
arm-unknown-linux-musleabi      powerpc64le-unknown-linux-musl
arm-unknown-linux-musleabihf    s390x-unknown-linux-gnu
armebv7r-none-eabihf            sparc-unknown-linux-gnu
armv4t-unknown-linux-gnueabi    sparc64-unknown-linux-gnu
armv5te-unknown-linux-gnueabi   sparc64-unknown-netbsd
armv5te-unknown-linux-musleabi  sparcv9-sun-solaris
armv6-unknown-netbsd-eabihf     thumbv6m-none-eabi
armv7-linux-androideabi         thumbv7em-none-eabi
armv7-unknown-cloudabi-eabihf   thumbv7em-none-eabihf
armv7-unknown-linux-gnueabihf   thumbv7m-none-eabi
armv7-unknown-linux-musleabihf  wasm32-experimental-emscripten
armv7-unknown-netbsd-eabihf     wasm32-unknown-emscripten
asmjs-unknown-emscripten        wasm32-unknown-unknown
i586-pc-windows-msvc            x86_64-apple-darwin
i586-unknown-linux-gnu          x86_64-fuchsia
i586-unknown-linux-musl         x86_64-linux-android
i686-apple-darwin               x86_64-pc-windows-gnu
i686-linux-android              x86_64-pc-windows-msvc
i686-pc-windows-gnu             x86_64-rumprun-netbsd
i686-pc-windows-msvc            x86_64-sun-solaris
i686-unknown-cloudabi           x86_64-unknown-bitrig
i686-unknown-dragonfly          x86_64-unknown-cloudabi
i686-unknown-freebsd            x86_64-unknown-dragonfly
i686-unknown-haiku              x86_64-unknown-freebsd
i686-unknown-linux-gnu          x86_64-unknown-haiku
i686-unknown-linux-musl         x86_64-unknown-l4re-uclibc
i686-unknown-netbsd             x86_64-unknown-linux-gnu
i686-unknown-openbsd            x86_64-unknown-linux-gnux32
mips-unknown-linux-gnu          x86_64-unknown-linux-musl
mips-unknown-linux-musl         x86_64-unknown-netbsd
mips-unknown-linux-uclibc       x86_64-unknown-openbsd
mips64-unknown-linux-gnuabi64   x86_64-unknown-redox
</code></pre>
<p>You can print the specification of any of these targets using the following command:</p>
<pre><code class="language-console">$ rustc +nightly -Z unstable-options --print target-spec-json --target thumbv7m-none-eabi
{
  &quot;abi-blacklist&quot;: [
    &quot;stdcall&quot;,
    &quot;fastcall&quot;,
    &quot;vectorcall&quot;,
    &quot;thiscall&quot;,
    &quot;win64&quot;,
    &quot;sysv64&quot;
  ],
  &quot;arch&quot;: &quot;arm&quot;,
  &quot;data-layout&quot;: &quot;e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64&quot;,
  &quot;emit-debug-gdb-scripts&quot;: false,
  &quot;env&quot;: &quot;&quot;,
  &quot;executables&quot;: true,
  &quot;is-builtin&quot;: true,
  &quot;linker&quot;: &quot;arm-none-eabi-gcc&quot;,
  &quot;linker-flavor&quot;: &quot;gcc&quot;,
  &quot;llvm-target&quot;: &quot;thumbv7m-none-eabi&quot;,
  &quot;max-atomic-width&quot;: 32,
  &quot;os&quot;: &quot;none&quot;,
  &quot;panic-strategy&quot;: &quot;abort&quot;,
  &quot;relocation-model&quot;: &quot;static&quot;,
  &quot;target-c-int-width&quot;: &quot;32&quot;,
  &quot;target-endian&quot;: &quot;little&quot;,
  &quot;target-pointer-width&quot;: &quot;32&quot;,
  &quot;vendor&quot;: &quot;&quot;
}
</code></pre>
<p>If none of these built-in targets seems appropriate for your target system, you'll have to create a
custom target by writing your own target specification file in JSON format. The recommended way is to
dump the specification of a built-in target that's similar to your target system into a file and then
tweak it to match the properties of your target system. To do so, use the previously shown command,
<code>rustc --print target-spec-json</code>. As of Rust 1.28, there's no up to date documentation on what each of
the fields of a target specification mean, other than <a href="https://github.com/rust-lang/rust/blob/1.27.2/src/librustc_target/spec/mod.rs#L376-L400">the compiler source code</a>.</p>
<p>Once you have a target specification file you can refer to it by its path or by its name if its in
the current directory or in <code>$RUST_TARGET_PATH</code>.</p>
<pre><code class="language-console">$ rustc +nightly -Z unstable-options --print target-spec-json \
      --target thumbv7m-none-eabi \
      &gt; foo.json

$ rustc --print cfg --target foo.json # or just --target foo
debug_assertions
target_arch=&quot;arm&quot;
target_endian=&quot;little&quot;
target_env=&quot;&quot;
target_feature=&quot;mclass&quot;
target_feature=&quot;v7&quot;
target_has_atomic=&quot;16&quot;
target_has_atomic=&quot;32&quot;
target_has_atomic=&quot;8&quot;
target_has_atomic=&quot;cas&quot;
target_has_atomic=&quot;ptr&quot;
target_os=&quot;none&quot;
target_pointer_width=&quot;32&quot;
target_vendor=&quot;&quot;
</code></pre>
<a class="header" href="#rust-std-component" id="rust-std-component"><h2><code>rust-std</code> component</h2></a>
<p>For some of the built-in target the Rust team distributes <code>rust-std</code> components via <code>rustup</code>. This
component is a collection of pre-compiled crates like <code>core</code> and <code>std</code>, and it's required for
cross compilation.</p>
<p>You can find the list of targets that have a <code>rust-std</code> component available via <code>rustup</code> by running
the following command:</p>
<pre><code class="language-console">$ rustup target list | column
aarch64-apple-ios                       mips64-unknown-linux-gnuabi64
aarch64-linux-android                   mips64el-unknown-linux-gnuabi64
aarch64-unknown-fuchsia                 mipsel-unknown-linux-gnu
aarch64-unknown-linux-gnu               mipsel-unknown-linux-musl
aarch64-unknown-linux-musl              powerpc-unknown-linux-gnu
arm-linux-androideabi                   powerpc64-unknown-linux-gnu
arm-unknown-linux-gnueabi               powerpc64le-unknown-linux-gnu
arm-unknown-linux-gnueabihf             s390x-unknown-linux-gnu
arm-unknown-linux-musleabi              sparc64-unknown-linux-gnu
arm-unknown-linux-musleabihf            sparcv9-sun-solaris
armv5te-unknown-linux-gnueabi           thumbv6m-none-eabi
armv5te-unknown-linux-musleabi          thumbv7em-none-eabi
armv7-apple-ios                         thumbv7em-none-eabihf
armv7-linux-androideabi                 thumbv7m-none-eabi
armv7-unknown-linux-gnueabihf           wasm32-unknown-emscripten
armv7-unknown-linux-musleabihf          wasm32-unknown-unknown
armv7s-apple-ios                        x86_64-apple-darwin
asmjs-unknown-emscripten                x86_64-apple-ios
i386-apple-ios                          x86_64-linux-android
i586-pc-windows-msvc                    x86_64-pc-windows-gnu
i586-unknown-linux-gnu                  x86_64-pc-windows-msvc
i586-unknown-linux-musl                 x86_64-rumprun-netbsd
i686-apple-darwin                       x86_64-sun-solaris
i686-linux-android                      x86_64-unknown-cloudabi
i686-pc-windows-gnu                     x86_64-unknown-freebsd
i686-pc-windows-msvc                    x86_64-unknown-fuchsia
i686-unknown-freebsd                    x86_64-unknown-linux-gnu (default)
i686-unknown-linux-gnu                  x86_64-unknown-linux-gnux32
i686-unknown-linux-musl                 x86_64-unknown-linux-musl
mips-unknown-linux-gnu                  x86_64-unknown-netbsd
mips-unknown-linux-musl                 x86_64-unknown-redox
</code></pre>
<p>If there's no <code>rust-std</code> component for your target or you are using a custom target, then you'll have
to use a tool like <a href="https://github.com/japaric/xargo">Xargo</a> to have Cargo compile the <code>core</code> crate on the fly. Note that Xargo
requires a nightly toolchain; the long term plan is to upstream Xargo's functionality into Cargo
and eventually have that functionality available on stable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
